"use strict";
// All credit goes to the incredible folks at Nx who use this code to update the app styles when adding tailwind
// Check out the code here: https://github.com/nrwl/nx/blob/master/packages/angular/src/generators/setup-tailwind/lib/update-application-styles.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.addThemeToApplicationStyles = void 0;
const devkit_1 = require("@nx/devkit");
const supported_theme_generator_map_1 = require("./supported-theme-generator-map");
function addThemeToApplicationStyles(tree, options, project) {
    const prefix = options.prefix ? ` .${options.prefix}` : '';
    let stylesEntryPoint = options.stylesEntryPoint;
    if (stylesEntryPoint && !tree.exists(stylesEntryPoint)) {
        throw new Error(`The provided styles entry point "${stylesEntryPoint}" could not be found.`);
    }
    if (!stylesEntryPoint) {
        stylesEntryPoint = findStylesEntryPoint(tree, project);
        if (!stylesEntryPoint) {
            throw new Error((0, devkit_1.stripIndents) `Could not find a styles entry point for project "${options.project}".
        Please specify a styles entry point using the "stylesEntryPoint" option.`);
        }
    }
    const stylesEntryPointContent = tree.read(stylesEntryPoint, 'utf-8');
    const CDK_IMPORT = `@import '@angular/cdk/overlay-prebuilt.css';`;
    const ckdOverlayImport = stylesEntryPointContent.includes(CDK_IMPORT) ? '' : CDK_IMPORT;
    const rootFontSans = stylesEntryPointContent.includes('--font-sans')
        ? ''
        : `:root {
     --font-sans: ''
     }`;
    tree.write(stylesEntryPoint, (0, devkit_1.stripIndents) `
    ${ckdOverlayImport}

    ${stylesEntryPointContent}

    ${rootFontSans}
    ${supported_theme_generator_map_1.SupportedThemeGeneratorMap[options.theme](options.radius, prefix)}`);
}
exports.addThemeToApplicationStyles = addThemeToApplicationStyles;
function findStylesEntryPoint(tree, project) {
    var _a, _b, _c, _d, _e, _f;
    // first check for common names
    const possibleStylesEntryPoints = [
        (0, devkit_1.joinPathFragments)((_a = project.sourceRoot) !== null && _a !== void 0 ? _a : project.root, 'styles.css'),
        (0, devkit_1.joinPathFragments)((_b = project.sourceRoot) !== null && _b !== void 0 ? _b : project.root, 'styles.scss'),
        (0, devkit_1.joinPathFragments)((_c = project.sourceRoot) !== null && _c !== void 0 ? _c : project.root, 'styles.sass'),
        (0, devkit_1.joinPathFragments)((_d = project.sourceRoot) !== null && _d !== void 0 ? _d : project.root, 'styles.less'),
    ];
    const stylesEntryPoint = possibleStylesEntryPoints.find((s) => tree.exists(s));
    if (stylesEntryPoint) {
        return stylesEntryPoint;
    }
    // then check for the specified styles in the build configuration if it exists
    const styles = (_f = (_e = project.targets) === null || _e === void 0 ? void 0 : _e['build'].options) === null || _f === void 0 ? void 0 : _f.styles;
    if (!styles) {
        return undefined;
    }
    // find the first style that belongs to the project source
    const style = styles.find((s) => typeof s === 'string'
        ? s.startsWith(project.root) && tree.exists(s)
        : s.input.startsWith(project.root) && s.inject !== false && tree.exists(s.input));
    if (!style) {
        return undefined;
    }
    return typeof style === 'string' ? style : style.input;
}
//# sourceMappingURL=add-theme-to-application-styles.js.map