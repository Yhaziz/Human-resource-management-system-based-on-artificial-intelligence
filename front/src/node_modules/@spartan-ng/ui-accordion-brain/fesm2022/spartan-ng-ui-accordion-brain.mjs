import * as i0 from '@angular/core';
import { inject, ElementRef, Directive, NgZone, signal, computed, ContentChildren, Input, input, effect, untracked, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { FocusMonitor, FocusKeyManager } from '@angular/cdk/a11y';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { rxHostPressedListener } from '@spartan-ng/ui-core';
import { fromEvent } from 'rxjs';

class BrnAccordionTriggerDirective {
    constructor() {
        this._accordion = inject(BrnAccordionDirective);
        this._item = inject(BrnAccordionItemDirective);
        this._elementRef = inject(ElementRef);
        this._hostPressedListener = rxHostPressedListener();
        this.state = this._item.state;
        this.id = 'brn-accordion-trigger-' + this._item.id;
        this.ariaControls = 'brn-accordion-content-' + this._item.id;
        if (!this._accordion) {
            throw Error('Accordion trigger can only be used inside an Accordion. Add brnAccordion to ancestor.');
        }
        if (!this._item) {
            throw Error('Accordion trigger can only be used inside an AccordionItem. Add brnAccordionItem to parent.');
        }
        this._hostPressedListener.subscribe(() => {
            this._accordion.toggleItem(this._item.id);
        });
        fromEvent(this._elementRef.nativeElement, 'focus')
            .pipe(takeUntilDestroyed())
            .subscribe(() => {
            this._accordion.setActiveItem(this);
        });
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnAccordionTriggerDirective, isStandalone: true, selector: "[brnAccordionTrigger]", host: { attributes: { "role": "heading", "aria-level": "3" }, properties: { "attr.data-state": "state()", "attr.aria-expanded": "state() === \"open\"", "attr.aria-controls": "ariaControls", "id": "id" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAccordionTrigger]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.aria-expanded]': 'state() === "open"',
                        '[attr.aria-controls]': 'ariaControls',
                        role: 'heading',
                        'aria-level': '3',
                        '[id]': 'id',
                    },
                }]
        }], ctorParameters: () => [] });

const HORIZONTAL_KEYS_TO_PREVENT_DEFAULT = [
    'ArrowLeft',
    'ArrowRight',
    'PageDown',
    'PageUp',
    'Home',
    'End',
    ' ',
    'Enter',
];
const VERTICAL_KEYS_TO_PREVENT_DEFAULT = ['ArrowUp', 'ArrowDown', 'PageDown', 'PageUp', 'Home', 'End', ' ', 'Enter'];
class BrnAccordionDirective {
    constructor() {
        this._el = inject(ElementRef);
        this._focusMonitor = inject(FocusMonitor);
        this._ngZone = inject(NgZone);
        this._focused = signal(false);
        this._openItemIds = signal([]);
        this.openItemIds = this._openItemIds.asReadonly();
        this.state = computed(() => (this._openItemIds().length > 0 ? 'open' : 'closed'));
        this.type = 'single';
        this.dir = null;
        this.orientation = 'vertical';
    }
    ngAfterContentInit() {
        if (!this.triggers) {
            return;
        }
        this._keyManager = new FocusKeyManager(this.triggers)
            .withHomeAndEnd()
            .withPageUpDown()
            .withWrap();
        if (this.orientation === 'horizontal') {
            this._keyManager.withHorizontalOrientation(this.dir ?? 'ltr').withVerticalOrientation(false);
        }
        this._el.nativeElement.addEventListener('keydown', (event) => {
            this._keyManager?.onKeydown(event);
            this.preventDefaultEvents(event);
        });
        this._focusMonitor.monitor(this._el, true).subscribe((origin) => this._focused.set(origin !== null));
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._el);
    }
    setActiveItem(item) {
        // public setActiveItem(item: number) {
        this._keyManager?.setActiveItem(item);
    }
    toggleItem(id) {
        if (this._openItemIds().includes(id)) {
            this.closeItem(id);
            return;
        }
        this.openItem(id);
    }
    openItem(id) {
        if (this.type === 'single') {
            this._openItemIds.set([id]);
            return;
        }
        this._openItemIds.update((ids) => [...ids, id]);
    }
    closeItem(id) {
        this._openItemIds.update((ids) => ids.filter((openId) => id !== openId));
    }
    preventDefaultEvents(event) {
        if (!this._focused())
            return;
        if (!('key' in event))
            return;
        const keys = this.orientation === 'horizontal' ? HORIZONTAL_KEYS_TO_PREVENT_DEFAULT : VERTICAL_KEYS_TO_PREVENT_DEFAULT;
        if (keys.includes(event.key) && event.code !== 'NumpadEnter') {
            event.preventDefault();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnAccordionDirective, isStandalone: true, selector: "[brnAccordion]", inputs: { type: "type", dir: "dir", orientation: "orientation" }, host: { properties: { "attr.data-state": "state()", "attr.data-orientation": "orientation" } }, queries: [{ propertyName: "triggers", predicate: BrnAccordionTriggerDirective, descendants: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAccordion]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.data-orientation]': 'orientation',
                    },
                }]
        }], propDecorators: { triggers: [{
                type: ContentChildren,
                args: [BrnAccordionTriggerDirective, { descendants: true }]
            }], type: [{
                type: Input
            }], dir: [{
                type: Input
            }], orientation: [{
                type: Input
            }] } });

let itemIdGenerator = 0;
class BrnAccordionItemDirective {
    constructor() {
        this._accordion = inject(BrnAccordionDirective);
        this.isOpened = input(false, { transform: coerceBooleanProperty });
        this.id = itemIdGenerator++;
        this.state = computed(() => (this._accordion.openItemIds().includes(this.id) ? 'open' : 'closed'));
        if (!this._accordion) {
            throw Error('Accordion trigger can only be used inside an Accordion. Add brnAccordion to ancestor.');
        }
        effect(() => {
            const isOpened = this.isOpened();
            untracked(() => {
                if (isOpened) {
                    this._accordion.openItem(this.id);
                }
                else {
                    this._accordion.closeItem(this.id);
                }
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "17.3.5", type: BrnAccordionItemDirective, isStandalone: true, selector: "[brnAccordionItem]", inputs: { isOpened: { classPropertyName: "isOpened", publicName: "isOpened", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.data-state": "state()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAccordionItem]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnAccordionContentComponent {
    constructor() {
        this._item = inject(BrnAccordionItemDirective);
        this.state = this._item.state;
        this.id = 'brn-accordion-content-' + this._item.id;
        this.ariaLabeledBy = 'brn-accordion-trigger-' + this._item.id;
        this._addInert = computed(() => (this.state() === 'closed' ? true : undefined));
        this._contentClass = signal('');
        if (!this._item) {
            throw Error('Accordion Content can only be used inside an AccordionItem. Add brnAccordionItem to parent.');
        }
    }
    setClassToCustomElement(classes) {
        this._contentClass.set(classes);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.5", type: BrnAccordionContentComponent, isStandalone: true, selector: "brn-accordion-content, hlm-accordion-content", host: { attributes: { "role": "region" }, properties: { "attr.data-state": "state()", "attr.aria-labelledby": "ariaLabeledBy", "id": "id" } }, ngImport: i0, template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-accordion-content, hlm-accordion-content',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.aria-labelledby]': 'ariaLabeledBy',
                        role: 'region',
                        '[id]': 'id',
                    },
                    template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: () => [] });

const BrnAccordionImports = [
    BrnAccordionDirective,
    BrnAccordionContentComponent,
    BrnAccordionItemDirective,
    BrnAccordionTriggerDirective,
];
class BrnAccordionModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionModule, imports: [BrnAccordionDirective,
            BrnAccordionContentComponent,
            BrnAccordionItemDirective,
            BrnAccordionTriggerDirective], exports: [BrnAccordionDirective,
            BrnAccordionContentComponent,
            BrnAccordionItemDirective,
            BrnAccordionTriggerDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAccordionModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnAccordionImports],
                    exports: [...BrnAccordionImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnAccordionContentComponent, BrnAccordionDirective, BrnAccordionImports, BrnAccordionItemDirective, BrnAccordionModule, BrnAccordionTriggerDirective };
//# sourceMappingURL=spartan-ng-ui-accordion-brain.mjs.map
