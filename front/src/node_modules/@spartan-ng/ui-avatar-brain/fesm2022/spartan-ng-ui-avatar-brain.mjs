import * as i0 from '@angular/core';
import { signal, computed, Directive, HostListener, Component, ChangeDetectionStrategy, ViewEncapsulation, ContentChild, inject, ElementRef, booleanAttribute, Input, Pipe, NgModule } from '@angular/core';
import { NgIf } from '@angular/common';

class BrnAvatarImageDirective {
    constructor() {
        this.error = signal(false);
        this.loaded = signal(false);
        this.canShow = computed(() => {
            return this.loaded() && !this.error();
        });
    }
    onError() {
        this.error.set(true);
    }
    onLoad() {
        this.loaded.set(true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarImageDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnAvatarImageDirective, isStandalone: true, selector: "img[brnAvatarImage]", host: { listeners: { "error": "onError()", "load": "onLoad()" } }, exportAs: ["avatarImage"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarImageDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'img[brnAvatarImage]',
                    standalone: true,
                    exportAs: 'avatarImage',
                }]
        }], propDecorators: { onError: [{
                type: HostListener,
                args: ['error']
            }], onLoad: [{
                type: HostListener,
                args: ['load']
            }] } });

class BrnAvatarComponent {
    constructor() {
        this.image = null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.5", type: BrnAvatarComponent, isStandalone: true, selector: "brn-avatar", queries: [{ propertyName: "image", first: true, predicate: BrnAvatarImageDirective, descendants: true, static: true }], ngImport: i0, template: `
		<ng-container *ngIf="image?.canShow(); else fallback">
			<ng-content select="[brnAvatarImage]" />
		</ng-container>
		<ng-template #fallback>
			<ng-content select="[brnAvatarFallback]" />
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-avatar',
                    standalone: true,
                    imports: [NgIf],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
		<ng-container *ngIf="image?.canShow(); else fallback">
			<ng-content select="[brnAvatarImage]" />
		</ng-container>
		<ng-template #fallback>
			<ng-content select="[brnAvatarFallback]" />
		</ng-template>
	`,
                }]
        }], propDecorators: { image: [{
                type: ContentChild,
                args: [BrnAvatarImageDirective, { static: true }]
            }] } });

class BrnAvatarFallbackDirective {
    constructor() {
        this.element = inject(ElementRef).nativeElement;
        this.userCls = signal('');
        this.useAutoColor = signal(false);
        this.textContent = inject(ElementRef).nativeElement.textContent;
    }
    getTextContent() {
        return this.element.textContent;
    }
    set class(cls) {
        this.userCls.set(cls);
    }
    set autoColor(value) {
        this.useAutoColor.set(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarFallbackDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.5", type: BrnAvatarFallbackDirective, isStandalone: true, selector: "[brnAvatarFallback]", inputs: { class: "class", autoColor: ["autoColor", "autoColor", booleanAttribute] }, exportAs: ["avatarFallback"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarFallbackDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAvatarFallback]',
                    standalone: true,
                    exportAs: 'avatarFallback',
                }]
        }], propDecorators: { class: [{
                type: Input
            }], autoColor: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

function hashString(str) {
    let h;
    for (let i = 0; i < str.length; i++)
        h = (Math.imul(31, h || 0) + str.charCodeAt(i)) | 0;
    return h || 0;
}
function hashManyTimes(times = 5, str) {
    let h = hashString(str);
    for (let i = 0; i < times; i++)
        h = hashString(String(h));
    return h;
}
function hexColorFor(str) {
    const hash = str.length <= 2 ? hashManyTimes(5, str) : hashString(str);
    let color = '#';
    for (let i = 0; i < 3; i += 1) {
        const value = (hash >> (i * 8)) & 0xff;
        color += `00${value.toString(16)}`.slice(-2);
    }
    return color;
}

const toInitial = (capitalize = true) => (word) => {
    const initial = word.charAt(0);
    return capitalize ? initial.toLocaleUpperCase() : initial;
};
const firstAndLast = (initials) => `${initials[0]}${initials[initials.length - 1]}`;
class InitialsPipe {
    transform(name, capitalize = true, firstAndLastOnly = true, delimiter = ' ') {
        if (!name)
            return '';
        const initials = name.trim().split(delimiter).filter(Boolean).map(toInitial(capitalize));
        if (firstAndLastOnly && initials.length > 1)
            return firstAndLast(initials);
        return initials.join('');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: InitialsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: InitialsPipe, isStandalone: true, name: "initials" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: InitialsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'initials',
                    standalone: true,
                }]
        }] });

const isShortHand = (hex) => hex.length === 3;
const cleanup = (hex) => {
    const noHash = hex.replace('#', '').trim().toLowerCase();
    if (!isShortHand(noHash))
        return noHash;
    return noHash
        .split('')
        .map((char) => char + char)
        .join('');
};
const isBright = (hex) => Number.parseInt(cleanup(hex), 16) > 0xffffff / 1.25;

const BrnAvatarImports = [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective];
class BrnAvatarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarModule, imports: [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective], exports: [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnAvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnAvatarImports],
                    exports: [...BrnAvatarImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective, BrnAvatarImports, BrnAvatarModule, InitialsPipe, hexColorFor, isBright };
//# sourceMappingURL=spartan-ng-ui-avatar-brain.mjs.map
