import { FocusMonitor } from '@angular/cdk/a11y';
import { NgStyle, isPlatformBrowser } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, PLATFORM_ID, Renderer2, ViewChild, ViewEncapsulation, booleanAttribute, computed, effect, forwardRef, inject, input, signal, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { rxHostPressedListener } from '@spartan-ng/ui-core';
import * as i0 from "@angular/core";
export const BRN_CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnCheckboxComponent),
    multi: true,
};
export function indeterminateBooleanAttribute(value) {
    if (value === 'indeterminate')
        return 'indeterminate';
    return booleanAttribute(value);
}
const CONTAINER_POST_FIX = '-checkbox';
export class BrnCheckboxComponent {
    // TODO should be changed to new model input when updated to Angular 17.2
    set checked(value) {
        this._checked.set(value);
    }
    set disabled(value) {
        this._disabled.set(value);
    }
    get disabled() {
        return this._disabled();
    }
    constructor() {
        this._renderer = inject(Renderer2);
        this._elementRef = inject(ElementRef);
        this._focusMonitor = inject(FocusMonitor);
        this._isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this._focusVisible = signal(false);
        this.focusVisible = this._focusVisible.asReadonly();
        this._focused = signal(false);
        this.focused = this._focused.asReadonly();
        this._checked = signal(false);
        this.isChecked = this._checked.asReadonly();
        this._dataState = computed(() => {
            const checked = this._checked();
            if (checked === 'indeterminate')
                return 'indeterminate';
            return checked ? 'checked' : 'unchecked';
        });
        this._ariaChecked = computed(() => {
            const checked = this._checked();
            if (checked === 'indeterminate')
                return 'mixed';
            return checked ? 'true' : 'false';
        });
        this._value = computed(() => {
            const checked = this._checked();
            if (checked === 'indeterminate')
                return '';
            return checked ? 'on' : 'off';
        });
        /** Used to set the id on the underlying input element. */
        this.id = input(null);
        this.hostId = computed(() => (this.id() ? this.id() + CONTAINER_POST_FIX : null));
        /** Used to set the name attribute on the underlying input element. */
        this.name = input(null);
        this.hostName = computed(() => (this.name() ? this.name() + CONTAINER_POST_FIX : null));
        /** Used to set the aria-label attribute on the underlying input element. */
        this.ariaLabel = input(null, { alias: 'aria-label' });
        /** Used to set the aria-labelledby attribute on the underlying input element. */
        this.ariaLabelledby = input(null, { alias: 'aria-labelledby' });
        this.ariaDescribedby = input(null, { alias: 'aria-describedby' });
        this.required = input(false, { transform: booleanAttribute });
        // TODO should be changed to new model input when updated to Angular 17.2
        this._disabled = signal(false);
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,,@typescript-eslint/no-explicit-any
        this._onChange = (_) => { };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onTouched = () => { };
        this.changed = new EventEmitter();
        rxHostPressedListener().subscribe(() => this.handleChange());
        effect(() => {
            const parent = this._renderer.parentNode(this._elementRef.nativeElement);
            if (!parent)
                return;
            // check if parent is a label and assume it is for this checkbox
            if (parent?.tagName === 'LABEL') {
                this._renderer.setAttribute(parent, 'data-disabled', this._disabled() ? 'true' : 'false');
                return;
            }
            if (!this._isBrowser)
                return;
            const label = parent?.querySelector(`label[for="${this.id()}"]`);
            if (!label)
                return;
            this._renderer.setAttribute(label, 'data-disabled', this._disabled() ? 'true' : 'false');
        });
    }
    handleChange() {
        if (this._disabled())
            return;
        if (!this.checkbox)
            return;
        const previousChecked = this._checked();
        this._checked.set(previousChecked === 'indeterminate' ? true : !previousChecked);
        this._onChange(!previousChecked);
        this.changed.emit(!previousChecked);
    }
    ngAfterContentInit() {
        this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
            if (focusOrigin)
                this._focused.set(true);
            if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
                this._focusVisible.set(true);
            }
            if (!focusOrigin) {
                // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                // Angular does not expect events to be raised during change detection, so any state
                // change (such as a form control's ng-touched) will cause a changed-after-checked error.
                // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                // telling the form control it has been touched until the next tick.
                Promise.resolve().then(() => {
                    this._focusVisible.set(false);
                    this._focused.set(false);
                    this._onTouched();
                });
            }
        });
        if (!this.checkbox)
            return;
        this.checkbox.nativeElement.indeterminate = this._checked() === 'indeterminate';
        if (this.checkbox.nativeElement.indeterminate) {
            this.checkbox.nativeElement.value = 'indeterminate';
        }
        else {
            this.checkbox.nativeElement.value = this._checked() ? 'on' : 'off';
        }
        this.checkbox.nativeElement.dispatchEvent(new Event('change'));
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    writeValue(value) {
        if (value === 'indeterminate') {
            this.checked = 'indeterminate';
        }
        else {
            this.checked = !!value;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /** Implemented as a part of ControlValueAccessor. */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnCheckboxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "17.3.5", type: BrnCheckboxComponent, isStandalone: true, selector: "brn-checkbox", inputs: { checked: { classPropertyName: "checked", publicName: "checked", isSignal: false, isRequired: false, transformFunction: indeterminateBooleanAttribute }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, name: { classPropertyName: "name", publicName: "name", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "aria-label", isSignal: true, isRequired: false, transformFunction: null }, ariaLabelledby: { classPropertyName: "ariaLabelledby", publicName: "aria-labelledby", isSignal: true, isRequired: false, transformFunction: null }, ariaDescribedby: { classPropertyName: "ariaDescribedby", publicName: "aria-describedby", isSignal: true, isRequired: false, transformFunction: null }, required: { classPropertyName: "required", publicName: "required", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: false, isRequired: false, transformFunction: booleanAttribute } }, outputs: { changed: "changed" }, host: { properties: { "attr.tabindex": "_disabled() ? \"-1\" : \"0\"", "attr.data-state": "_dataState()", "attr.data-focus-visible": "focusVisible()", "attr.data-focus": "focused()", "attr.data-disabled": "_disabled()", "attr.aria-labelledby": "null", "attr.aria-label": "null", "attr.aria-describedby": "null", "attr.id": "hostId()", "attr.name": "hostName()" } }, providers: [BRN_CHECKBOX_VALUE_ACCESSOR], viewQueries: [{ propertyName: "checkbox", first: true, predicate: ["checkBox"], descendants: true, static: true }], ngImport: i0, template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="checkbox"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: '-1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0'
			}"
			[id]="id() ?? ''"
			[name]="name() ?? ''"
			[value]="_value()"
			[checked]="isChecked()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			[attr.aria-required]="required() || null"
			[attr.aria-checked]="_ariaChecked()"
		/>
		<ng-content />
	`, isInline: true, dependencies: [{ kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnCheckboxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-checkbox',
                    standalone: true,
                    imports: [NgStyle],
                    template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="checkbox"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: '-1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0'
			}"
			[id]="id() ?? ''"
			[name]="name() ?? ''"
			[value]="_value()"
			[checked]="isChecked()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			[attr.aria-required]="required() || null"
			[attr.aria-checked]="_ariaChecked()"
		/>
		<ng-content />
	`,
                    host: {
                        '[attr.tabindex]': '_disabled() ? "-1" : "0"',
                        '[attr.data-state]': '_dataState()',
                        '[attr.data-focus-visible]': 'focusVisible()',
                        '[attr.data-focus]': 'focused()',
                        '[attr.data-disabled]': '_disabled()',
                        '[attr.aria-labelledby]': 'null',
                        '[attr.aria-label]': 'null',
                        '[attr.aria-describedby]': 'null',
                        '[attr.id]': 'hostId()',
                        '[attr.name]': 'hostName()',
                    },
                    providers: [BRN_CHECKBOX_VALUE_ACCESSOR],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: () => [], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: indeterminateBooleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], checkbox: [{
                type: ViewChild,
                args: ['checkBox', { static: true }]
            }], changed: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJuLWNoZWNrYm94LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvdWkvY2hlY2tib3gvYnJhaW4vc3JjL2xpYi9icm4tY2hlY2tib3guY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDN0QsT0FBTyxFQUNOLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFdBQVcsRUFDWCxTQUFTLEVBQ1QsU0FBUyxFQUNULGlCQUFpQixFQUNqQixnQkFBZ0IsRUFDaEIsUUFBUSxFQUNSLE1BQU0sRUFDTixVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxNQUFNLEdBR04sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0scUJBQXFCLENBQUM7O0FBRTVELE1BQU0sQ0FBQyxNQUFNLDJCQUEyQixHQUFHO0lBQzFDLE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztJQUNuRCxLQUFLLEVBQUUsSUFBSTtDQUNYLENBQUM7QUFFRixNQUFNLFVBQVUsNkJBQTZCLENBQUMsS0FBYztJQUMzRCxJQUFJLEtBQUssS0FBSyxlQUFlO1FBQUUsT0FBTyxlQUFlLENBQUM7SUFDdEQsT0FBTyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRUQsTUFBTSxrQkFBa0IsR0FBRyxXQUFXLENBQUM7QUFvRHZDLE1BQU0sT0FBTyxvQkFBb0I7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QUM3QyxtQkFBbUIsRUFBRSxXQUFXO3dCQUNoQyxzQkFBc0IsRUFBRSxhQUFhO3dCQUNyQyx3QkFBd0IsRUFBRSxNQUFNO3dCQUNoQyxtQkFBbUIsRUFBRSxNQUFNO3dCQUMzQix5QkFBeUIsRUFBRSxNQUFNO3dCQUNqQyxXQUFXLEVBQUUsVUFBVTt3QkFDdkIsYUFBYSxFQUFFLFlBQVk7cUJBQzNCO29CQUNELFNBQVMsRUFBRSxDQUFDLDJCQUEyQixDQUFDO29CQUN4QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7aUJBQ3JDO3dEQWlDSSxPQUFPO3NCQURWLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsNkJBQTZCLEVBQUU7Z0JBMEIvQyxRQUFRO3NCQURYLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBZS9CLFFBQVE7c0JBRGQsU0FBUzt1QkFBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUl2QixPQUFPO3NCQUR0QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgTmdTdHlsZSwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcblx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG5cdENvbXBvbmVudCxcblx0RWxlbWVudFJlZixcblx0RXZlbnRFbWl0dGVyLFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRQTEFURk9STV9JRCxcblx0UmVuZGVyZXIyLFxuXHRWaWV3Q2hpbGQsXG5cdFZpZXdFbmNhcHN1bGF0aW9uLFxuXHRib29sZWFuQXR0cmlidXRlLFxuXHRjb21wdXRlZCxcblx0ZWZmZWN0LFxuXHRmb3J3YXJkUmVmLFxuXHRpbmplY3QsXG5cdGlucHV0LFxuXHRzaWduYWwsXG5cdHR5cGUgQWZ0ZXJDb250ZW50SW5pdCxcblx0dHlwZSBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyByeEhvc3RQcmVzc2VkTGlzdGVuZXIgfSBmcm9tICdAc3BhcnRhbi1uZy91aS1jb3JlJztcblxuZXhwb3J0IGNvbnN0IEJSTl9DSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUiA9IHtcblx0cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG5cdHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEJybkNoZWNrYm94Q29tcG9uZW50KSxcblx0bXVsdGk6IHRydWUsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXRlcm1pbmF0ZUJvb2xlYW5BdHRyaWJ1dGUodmFsdWU6IHVua25vd24pOiBib29sZWFuIHwgJ2luZGV0ZXJtaW5hdGUnIHtcblx0aWYgKHZhbHVlID09PSAnaW5kZXRlcm1pbmF0ZScpIHJldHVybiAnaW5kZXRlcm1pbmF0ZSc7XG5cdHJldHVybiBib29sZWFuQXR0cmlidXRlKHZhbHVlKTtcbn1cblxuY29uc3QgQ09OVEFJTkVSX1BPU1RfRklYID0gJy1jaGVja2JveCc7XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ2Jybi1jaGVja2JveCcsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdGltcG9ydHM6IFtOZ1N0eWxlXSxcblx0dGVtcGxhdGU6IGBcblx0XHQ8aW5wdXRcblx0XHRcdCNjaGVja0JveFxuXHRcdFx0dGFiaW5kZXg9XCItMVwiXG5cdFx0XHR0eXBlPVwiY2hlY2tib3hcIlxuXHRcdFx0cm9sZT1cImNoZWNrYm94XCJcblx0XHRcdFtuZ1N0eWxlXT1cIntcblx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdHdpZHRoOiAnMXB4Jyxcblx0XHRcdFx0aGVpZ2h0OiAnMXB4Jyxcblx0XHRcdFx0cGFkZGluZzogJzAnLFxuXHRcdFx0XHRtYXJnaW46ICctMXB4Jyxcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRjbGlwOiAncmVjdCgwLCAwLCAwLCAwKScsXG5cdFx0XHRcdHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogJzAnXG5cdFx0XHR9XCJcblx0XHRcdFtpZF09XCJpZCgpID8/ICcnXCJcblx0XHRcdFtuYW1lXT1cIm5hbWUoKSA/PyAnJ1wiXG5cdFx0XHRbdmFsdWVdPVwiX3ZhbHVlKClcIlxuXHRcdFx0W2NoZWNrZWRdPVwiaXNDaGVja2VkKClcIlxuXHRcdFx0W3JlcXVpcmVkXT1cInJlcXVpcmVkKClcIlxuXHRcdFx0W2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWwoKVwiXG5cdFx0XHRbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkYnkoKVwiXG5cdFx0XHRbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XT1cImFyaWFEZXNjcmliZWRieSgpXCJcblx0XHRcdFthdHRyLmFyaWEtcmVxdWlyZWRdPVwicmVxdWlyZWQoKSB8fCBudWxsXCJcblx0XHRcdFthdHRyLmFyaWEtY2hlY2tlZF09XCJfYXJpYUNoZWNrZWQoKVwiXG5cdFx0Lz5cblx0XHQ8bmctY29udGVudCAvPlxuXHRgLFxuXHRob3N0OiB7XG5cdFx0J1thdHRyLnRhYmluZGV4XSc6ICdfZGlzYWJsZWQoKSA/IFwiLTFcIiA6IFwiMFwiJyxcblx0XHQnW2F0dHIuZGF0YS1zdGF0ZV0nOiAnX2RhdGFTdGF0ZSgpJyxcblx0XHQnW2F0dHIuZGF0YS1mb2N1cy12aXNpYmxlXSc6ICdmb2N1c1Zpc2libGUoKScsXG5cdFx0J1thdHRyLmRhdGEtZm9jdXNdJzogJ2ZvY3VzZWQoKScsXG5cdFx0J1thdHRyLmRhdGEtZGlzYWJsZWRdJzogJ19kaXNhYmxlZCgpJyxcblx0XHQnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdudWxsJyxcblx0XHQnW2F0dHIuYXJpYS1sYWJlbF0nOiAnbnVsbCcsXG5cdFx0J1thdHRyLmFyaWEtZGVzY3JpYmVkYnldJzogJ251bGwnLFxuXHRcdCdbYXR0ci5pZF0nOiAnaG9zdElkKCknLFxuXHRcdCdbYXR0ci5uYW1lXSc6ICdob3N0TmFtZSgpJyxcblx0fSxcblx0cHJvdmlkZXJzOiBbQlJOX0NIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG5cdGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuZXhwb3J0IGNsYXNzIEJybkNoZWNrYm94Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblx0cHJpdmF0ZSByZWFkb25seSBfcmVuZGVyZXIgPSBpbmplY3QoUmVuZGVyZXIyKTtcblx0cHJpdmF0ZSByZWFkb25seSBfZWxlbWVudFJlZiA9IGluamVjdChFbGVtZW50UmVmKTtcblx0cHJpdmF0ZSByZWFkb25seSBfZm9jdXNNb25pdG9yID0gaW5qZWN0KEZvY3VzTW9uaXRvcik7XG5cdHByaXZhdGUgcmVhZG9ubHkgX2lzQnJvd3NlciA9IGlzUGxhdGZvcm1Ccm93c2VyKGluamVjdChQTEFURk9STV9JRCkpO1xuXG5cdHByaXZhdGUgcmVhZG9ubHkgX2ZvY3VzVmlzaWJsZSA9IHNpZ25hbChmYWxzZSk7XG5cdHB1YmxpYyByZWFkb25seSBmb2N1c1Zpc2libGUgPSB0aGlzLl9mb2N1c1Zpc2libGUuYXNSZWFkb25seSgpO1xuXHRwcml2YXRlIHJlYWRvbmx5IF9mb2N1c2VkID0gc2lnbmFsKGZhbHNlKTtcblx0cHVibGljIHJlYWRvbmx5IGZvY3VzZWQgPSB0aGlzLl9mb2N1c2VkLmFzUmVhZG9ubHkoKTtcblxuXHRwcml2YXRlIHJlYWRvbmx5IF9jaGVja2VkID0gc2lnbmFsPGJvb2xlYW4gfCAnaW5kZXRlcm1pbmF0ZSc+KGZhbHNlKTtcblx0cHVibGljIHJlYWRvbmx5IGlzQ2hlY2tlZCA9IHRoaXMuX2NoZWNrZWQuYXNSZWFkb25seSgpO1xuXG5cdHByb3RlY3RlZCByZWFkb25seSBfZGF0YVN0YXRlID0gY29tcHV0ZWQoKCkgPT4ge1xuXHRcdGNvbnN0IGNoZWNrZWQgPSB0aGlzLl9jaGVja2VkKCk7XG5cdFx0aWYgKGNoZWNrZWQgPT09ICdpbmRldGVybWluYXRlJykgcmV0dXJuICdpbmRldGVybWluYXRlJztcblx0XHRyZXR1cm4gY2hlY2tlZCA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnO1xuXHR9KTtcblx0cHJvdGVjdGVkIHJlYWRvbmx5IF9hcmlhQ2hlY2tlZCA9IGNvbXB1dGVkKCgpID0+IHtcblx0XHRjb25zdCBjaGVja2VkID0gdGhpcy5fY2hlY2tlZCgpO1xuXHRcdGlmIChjaGVja2VkID09PSAnaW5kZXRlcm1pbmF0ZScpIHJldHVybiAnbWl4ZWQnO1xuXHRcdHJldHVybiBjaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcblx0fSk7XG5cdHByb3RlY3RlZCByZWFkb25seSBfdmFsdWUgPSBjb21wdXRlZCgoKSA9PiB7XG5cdFx0Y29uc3QgY2hlY2tlZCA9IHRoaXMuX2NoZWNrZWQoKTtcblx0XHRpZiAoY2hlY2tlZCA9PT0gJ2luZGV0ZXJtaW5hdGUnKSByZXR1cm4gJyc7XG5cdFx0cmV0dXJuIGNoZWNrZWQgPyAnb24nIDogJ29mZic7XG5cdH0pO1xuXG5cdC8vIFRPRE8gc2hvdWxkIGJlIGNoYW5nZWQgdG8gbmV3IG1vZGVsIGlucHV0IHdoZW4gdXBkYXRlZCB0byBBbmd1bGFyIDE3LjJcblx0QElucHV0KHsgdHJhbnNmb3JtOiBpbmRldGVybWluYXRlQm9vbGVhbkF0dHJpYnV0ZSB9KVxuXHRzZXQgY2hlY2tlZCh2YWx1ZTogYm9vbGVhbiB8ICdpbmRldGVybWluYXRlJykge1xuXHRcdHRoaXMuX2NoZWNrZWQuc2V0KHZhbHVlKTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIHNldCB0aGUgaWQgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cblx0cHVibGljIHJlYWRvbmx5IGlkID0gaW5wdXQ8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cdHByb3RlY3RlZCByZWFkb25seSBob3N0SWQgPSBjb21wdXRlZCgoKSA9PiAodGhpcy5pZCgpID8gdGhpcy5pZCgpICsgQ09OVEFJTkVSX1BPU1RfRklYIDogbnVsbCkpO1xuXG5cdC8qKiBVc2VkIHRvIHNldCB0aGUgbmFtZSBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cblx0cHVibGljIHJlYWRvbmx5IG5hbWUgPSBpbnB1dDxzdHJpbmcgfCBudWxsPihudWxsKTtcblx0cHJvdGVjdGVkIHJlYWRvbmx5IGhvc3ROYW1lID0gY29tcHV0ZWQoKCkgPT4gKHRoaXMubmFtZSgpID8gdGhpcy5uYW1lKCkgKyBDT05UQUlORVJfUE9TVF9GSVggOiBudWxsKSk7XG5cblx0LyoqIFVzZWQgdG8gc2V0IHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgYXJpYUxhYmVsID0gaW5wdXQ8c3RyaW5nIHwgbnVsbD4obnVsbCwgeyBhbGlhczogJ2FyaWEtbGFiZWwnIH0pO1xuXG5cdC8qKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgYXJpYUxhYmVsbGVkYnkgPSBpbnB1dDxzdHJpbmcgfCBudWxsPihudWxsLCB7IGFsaWFzOiAnYXJpYS1sYWJlbGxlZGJ5JyB9KTtcblxuXHRwdWJsaWMgcmVhZG9ubHkgYXJpYURlc2NyaWJlZGJ5ID0gaW5wdXQ8c3RyaW5nIHwgbnVsbD4obnVsbCwgeyBhbGlhczogJ2FyaWEtZGVzY3JpYmVkYnknIH0pO1xuXG5cdHB1YmxpYyByZWFkb25seSByZXF1aXJlZCA9IGlucHV0KGZhbHNlLCB7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KTtcblxuXHQvLyBUT0RPIHNob3VsZCBiZSBjaGFuZ2VkIHRvIG5ldyBtb2RlbCBpbnB1dCB3aGVuIHVwZGF0ZWQgdG8gQW5ndWxhciAxNy4yXG5cdHByb3RlY3RlZCByZWFkb25seSBfZGlzYWJsZWQgPSBzaWduYWwoZmFsc2UpO1xuXHRASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcblx0c2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0dGhpcy5fZGlzYWJsZWQuc2V0KHZhbHVlKTtcblx0fVxuXG5cdGdldCBkaXNhYmxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlzYWJsZWQoKTtcblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cdHByb3RlY3RlZCBfb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7fTtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuXHRwcml2YXRlIF9vblRvdWNoZWQgPSAoKSA9PiB7fTtcblxuXHRAVmlld0NoaWxkKCdjaGVja0JveCcsIHsgc3RhdGljOiB0cnVlIH0pXG5cdHB1YmxpYyBjaGVja2JveD86IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XG5cblx0QE91dHB1dCgpXG5cdHB1YmxpYyByZWFkb25seSBjaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuIHwgJ2luZGV0ZXJtaW5hdGUnPigpO1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHJ4SG9zdFByZXNzZWRMaXN0ZW5lcigpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhhbmRsZUNoYW5nZSgpKTtcblx0XHRlZmZlY3QoKCkgPT4ge1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5fcmVuZGVyZXIucGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXHRcdFx0aWYgKCFwYXJlbnQpIHJldHVybjtcblx0XHRcdC8vIGNoZWNrIGlmIHBhcmVudCBpcyBhIGxhYmVsIGFuZCBhc3N1bWUgaXQgaXMgZm9yIHRoaXMgY2hlY2tib3hcblx0XHRcdGlmIChwYXJlbnQ/LnRhZ05hbWUgPT09ICdMQUJFTCcpIHtcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHBhcmVudCwgJ2RhdGEtZGlzYWJsZWQnLCB0aGlzLl9kaXNhYmxlZCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5faXNCcm93c2VyKSByZXR1cm47XG5cblx0XHRcdGNvbnN0IGxhYmVsID0gcGFyZW50Py5xdWVyeVNlbGVjdG9yKGBsYWJlbFtmb3I9XCIke3RoaXMuaWQoKX1cIl1gKTtcblx0XHRcdGlmICghbGFiZWwpIHJldHVybjtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShsYWJlbCwgJ2RhdGEtZGlzYWJsZWQnLCB0aGlzLl9kaXNhYmxlZCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG5cdFx0fSk7XG5cdH1cblxuXHRoYW5kbGVDaGFuZ2UoKSB7XG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkKCkpIHJldHVybjtcblx0XHRpZiAoIXRoaXMuY2hlY2tib3gpIHJldHVybjtcblx0XHRjb25zdCBwcmV2aW91c0NoZWNrZWQgPSB0aGlzLl9jaGVja2VkKCk7XG5cdFx0dGhpcy5fY2hlY2tlZC5zZXQocHJldmlvdXNDaGVja2VkID09PSAnaW5kZXRlcm1pbmF0ZScgPyB0cnVlIDogIXByZXZpb3VzQ2hlY2tlZCk7XG5cdFx0dGhpcy5fb25DaGFuZ2UoIXByZXZpb3VzQ2hlY2tlZCk7XG5cdFx0dGhpcy5jaGFuZ2VkLmVtaXQoIXByZXZpb3VzQ2hlY2tlZCk7XG5cdH1cblxuXHRuZ0FmdGVyQ29udGVudEluaXQoKSB7XG5cdFx0dGhpcy5fZm9jdXNNb25pdG9yLm1vbml0b3IodGhpcy5fZWxlbWVudFJlZiwgdHJ1ZSkuc3Vic2NyaWJlKChmb2N1c09yaWdpbikgPT4ge1xuXHRcdFx0aWYgKGZvY3VzT3JpZ2luKSB0aGlzLl9mb2N1c2VkLnNldCh0cnVlKTtcblx0XHRcdGlmIChmb2N1c09yaWdpbiA9PT0gJ2tleWJvYXJkJyB8fCBmb2N1c09yaWdpbiA9PT0gJ3Byb2dyYW0nKSB7XG5cdFx0XHRcdHRoaXMuX2ZvY3VzVmlzaWJsZS5zZXQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWZvY3VzT3JpZ2luKSB7XG5cdFx0XHRcdC8vIFdoZW4gYSBmb2N1c2VkIGVsZW1lbnQgYmVjb21lcyBkaXNhYmxlZCwgdGhlIGJyb3dzZXIgKmltbWVkaWF0ZWx5KiBmaXJlcyBhIGJsdXIgZXZlbnQuXG5cdFx0XHRcdC8vIEFuZ3VsYXIgZG9lcyBub3QgZXhwZWN0IGV2ZW50cyB0byBiZSByYWlzZWQgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24sIHNvIGFueSBzdGF0ZVxuXHRcdFx0XHQvLyBjaGFuZ2UgKHN1Y2ggYXMgYSBmb3JtIGNvbnRyb2wncyBuZy10b3VjaGVkKSB3aWxsIGNhdXNlIGEgY2hhbmdlZC1hZnRlci1jaGVja2VkIGVycm9yLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTc3OTMuIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGRlZmVyXG5cdFx0XHRcdC8vIHRlbGxpbmcgdGhlIGZvcm0gY29udHJvbCBpdCBoYXMgYmVlbiB0b3VjaGVkIHVudGlsIHRoZSBuZXh0IHRpY2suXG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuX2ZvY3VzVmlzaWJsZS5zZXQoZmFsc2UpO1xuXHRcdFx0XHRcdHRoaXMuX2ZvY3VzZWQuc2V0KGZhbHNlKTtcblx0XHRcdFx0XHR0aGlzLl9vblRvdWNoZWQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMuY2hlY2tib3gpIHJldHVybjtcblxuXHRcdHRoaXMuY2hlY2tib3gubmF0aXZlRWxlbWVudC5pbmRldGVybWluYXRlID0gdGhpcy5fY2hlY2tlZCgpID09PSAnaW5kZXRlcm1pbmF0ZSc7XG5cdFx0aWYgKHRoaXMuY2hlY2tib3gubmF0aXZlRWxlbWVudC5pbmRldGVybWluYXRlKSB7XG5cdFx0XHR0aGlzLmNoZWNrYm94Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSAnaW5kZXRlcm1pbmF0ZSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2hlY2tib3gubmF0aXZlRWxlbWVudC52YWx1ZSA9IHRoaXMuX2NoZWNrZWQoKSA/ICdvbicgOiAnb2ZmJztcblx0XHR9XG5cdFx0dGhpcy5jaGVja2JveC5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSk7XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpIHtcblx0XHR0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5fZWxlbWVudFJlZik7XG5cdH1cblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXHR3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcblx0XHRpZiAodmFsdWUgPT09ICdpbmRldGVybWluYXRlJykge1xuXHRcdFx0dGhpcy5jaGVja2VkID0gJ2luZGV0ZXJtaW5hdGUnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNoZWNrZWQgPSAhIXZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuXHRcdHRoaXMuX29uQ2hhbmdlID0gZm47XG5cdH1cblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG5cdFx0dGhpcy5fb25Ub3VjaGVkID0gZm47XG5cdH1cblxuXHQvKiogSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcblx0XHR0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0fVxufVxuIl19