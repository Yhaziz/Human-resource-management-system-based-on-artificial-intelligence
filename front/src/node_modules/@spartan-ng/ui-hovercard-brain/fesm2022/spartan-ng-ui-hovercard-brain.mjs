import * as i0 from '@angular/core';
import { inject, ViewContainerRef, NgZone, ElementRef, Directive, Input, signal, TemplateRef, Injectable, Component, ContentChild, NgModule } from '@angular/core';
import { brnZoneOptimized, provideExposedSideProviderExisting, provideExposesStateProviderExisting } from '@spartan-ng/ui-core';
import { Overlay, OverlayPositionBuilder } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { toSignal } from '@angular/core/rxjs-interop';
import { Subject, map, merge, fromEvent, distinctUntilChanged, tap, switchMap, of, delay, share, takeUntil, filter, BehaviorSubject } from 'rxjs';
import { FocusMonitor } from '@angular/cdk/a11y';

/**
 * We are building on shoulders of giants here and use the implementation provided by the incredible TaigaUI
 * team: https://github.com/taiga-family/taiga-ui/blob/main/projects/core/directives/dropdown/dropdown-hover.directive.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */
function isElement(node) {
    return !!node && `nodeType` in node && node.nodeType === Node.ELEMENT_NODE;
}
class BrnHoverCardTriggerDirective {
    constructor() {
        this._destroy$ = new Subject();
        this._vcr = inject(ViewContainerRef);
        this._zone = inject(NgZone);
        this._el = inject(ElementRef);
        this._contentService = inject(BrnHoverCardContentService);
        this._focusMonitor = inject(FocusMonitor);
        this.focused$ = this._focusMonitor.monitor(this._el).pipe(map((e) => e !== null));
        this.hovered$ = merge(fromEvent(this._el.nativeElement, 'click').pipe(map(() => false)), createHoverObservable(this._el.nativeElement, this._zone, this._destroy$), this._contentService.hovered$, this.focused$).pipe(distinctUntilChanged());
        this.showing$ = this.hovered$.pipe(
        // we set the state to open here because we are about to open show the content
        tap((visible) => visible && this._contentService.setState('open')), switchMap((visible) => {
            // we are delaying based on the configure-able input
            return of(visible).pipe(delay(visible ? this.showDelay : this.hideDelay));
        }), switchMap((visible) => {
            // don't do anything when we are in the process of showing the content
            if (visible)
                return of(visible);
            // we set the state to closed here to trigger any animations for the element leaving
            this._contentService.setState('closed');
            // then delay to wait for the leaving animation to finish
            return of(visible).pipe(delay(this.animationDelay));
        }), distinctUntilChanged(), share(), takeUntil(this._destroy$));
        this.showDelay = 300;
        this.hideDelay = 500;
        this.animationDelay = 100;
        this.sideOffset = 5;
        this.align = 'bottom';
    }
    set brnHoverCardTriggerFor(value) {
        this._contentService.setContent(value, this._vcr);
    }
    ngOnInit() {
        this._contentService.setConfig({ attachTo: this._el, align: this.align, sideOffset: this.sideOffset });
        this.showing$.subscribe((isHovered) => {
            if (isHovered) {
                this._contentService.show();
            }
            else {
                this._contentService.hide();
            }
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnHoverCardTriggerDirective, isStandalone: true, selector: "[brnHoverCardTrigger]:not(ng-container),[brnHoverCardTriggerFor]:not(ng-container)", inputs: { showDelay: "showDelay", hideDelay: "hideDelay", animationDelay: "animationDelay", sideOffset: "sideOffset", align: "align", brnHoverCardTriggerFor: "brnHoverCardTriggerFor" }, exportAs: ["brnHoverCardTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnHoverCardTrigger]:not(ng-container),[brnHoverCardTriggerFor]:not(ng-container)',
                    standalone: true,
                    exportAs: 'brnHoverCardTrigger',
                }]
        }], propDecorators: { showDelay: [{
                type: Input
            }], hideDelay: [{
                type: Input
            }], animationDelay: [{
                type: Input
            }], sideOffset: [{
                type: Input
            }], align: [{
                type: Input
            }], brnHoverCardTriggerFor: [{
                type: Input
            }] } });

function movedOut({ currentTarget, relatedTarget }) {
    return !isElement(relatedTarget) || !isElement(currentTarget) || !currentTarget.contains(relatedTarget);
}
const createHoverObservable = (nativeElement, zone, destroyed$) => {
    return merge(fromEvent(nativeElement, `mouseenter`).pipe(map(() => true)), fromEvent(nativeElement, `mouseleave`).pipe(map(() => false)), 
    // Hello, Safari
    fromEvent(nativeElement, `mouseout`).pipe(filter(movedOut), map(() => false)), 
    /**
     * NOTE: onmouseout events don't trigger when objects move under mouse in Safari
     * https://bugs.webkit.org/show_bug.cgi?id=4117
     */
    fromEvent(nativeElement, `transitionend`).pipe(map(() => nativeElement.matches(`:hover`)))).pipe(distinctUntilChanged(), brnZoneOptimized(zone), takeUntil(destroyed$));
};

const topFirstPositions = [
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
];
const bottomFirstPositions = [
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
    },
];
class BrnHoverCardContentService {
    constructor() {
        this._overlay = inject(Overlay);
        this._zone = inject(NgZone);
        this._psBuilder = inject(OverlayPositionBuilder);
        this._content = signal(null);
        this._state = signal('closed');
        this._config = {};
        this._destroyed$ = new Subject();
        this._positionChangesObservables$ = new BehaviorSubject(undefined);
        this._overlayHoveredObservables$ = new BehaviorSubject(undefined);
        this.positionChanges$ = this._positionChangesObservables$.pipe(switchMap((positionChangeObservable) => (positionChangeObservable ? positionChangeObservable : of(undefined))), filter((change) => change !== undefined && change !== null));
        this.hovered$ = this._overlayHoveredObservables$.pipe(switchMap((overlayHoveredObservable) => (overlayHoveredObservable ? overlayHoveredObservable : of(false))));
        this.state = this._state.asReadonly();
        this.side = toSignal(this.positionChanges$.pipe(map((change) => 
        // todo: better translation or adjusting hlm to take that into account
        change.connectionPair.originY === 'center'
            ? change.connectionPair.originX === 'start'
                ? 'left'
                : 'right'
            : change.connectionPair.originY)), { initialValue: 'bottom' });
    }
    setConfig(config) {
        this._config = config;
        if (config['attachTo']) {
            this._positionStrategy = this._psBuilder
                .flexibleConnectedTo(config['attachTo'])
                .withPositions(config['attachPositions'] ?? config['align'] === 'top' ? topFirstPositions : bottomFirstPositions)
                .withDefaultOffsetY(config['sideOffset'] ?? 0);
            this._config = {
                ...this._config,
                positionStrategy: this._positionStrategy,
                scrollStrategy: this._overlay.scrollStrategies.reposition(),
            };
            this._positionChangesObservables$.next(this._positionStrategy.positionChanges);
        }
        this._overlayRef = this._overlay.create(this._config);
    }
    setContent(value, vcr) {
        this._content.set(new TemplatePortal(value instanceof TemplateRef ? value : value.template, vcr));
        if (!this._overlayRef) {
            this._overlayRef = this._overlay.create(this._config);
        }
    }
    setState(newState) {
        this._state.set(newState);
    }
    show() {
        const content = this._content();
        if (!content || !this._overlayRef)
            return;
        this._overlayRef?.detach();
        this._overlayRef?.attach(content);
        this._destroyed$ = new Subject();
        this._overlayHoveredObservables$.next(createHoverObservable(this._overlayRef.hostElement, this._zone, this._destroyed$));
    }
    hide() {
        this._overlayRef?.detach();
        this._destroyed$.next();
        this._destroyed$.complete();
        this._destroyed$ = new Subject();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardContentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardContentService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardContentService, decorators: [{
            type: Injectable
        }] });

class BrnHoverCardContentDirective {
    constructor() {
        this._contentService = inject(BrnHoverCardContentService);
        this.state = this._contentService.state;
        this.side = this._contentService.side;
        this.template = inject(TemplateRef);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardContentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnHoverCardContentDirective, isStandalone: true, selector: "[brnHoverCardContent]", providers: [
            provideExposedSideProviderExisting(() => BrnHoverCardContentDirective),
            provideExposesStateProviderExisting(() => BrnHoverCardContentDirective),
        ], exportAs: ["brnHoverCardContent"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnHoverCardContent]',
                    standalone: true,
                    exportAs: 'brnHoverCardContent',
                    providers: [
                        provideExposedSideProviderExisting(() => BrnHoverCardContentDirective),
                        provideExposesStateProviderExisting(() => BrnHoverCardContentDirective),
                    ],
                }]
        }] });

class BrnHoverCardComponent {
    ngAfterContentInit() {
        if (!this._trigger || !this._content)
            return;
        this._trigger.brnHoverCardTriggerFor = this._content;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.5", type: BrnHoverCardComponent, isStandalone: true, selector: "brn-hover-card", providers: [BrnHoverCardContentService], queries: [{ propertyName: "_trigger", first: true, predicate: BrnHoverCardTriggerDirective, descendants: true, static: true }, { propertyName: "_content", first: true, predicate: BrnHoverCardContentDirective, descendants: true, static: true }], ngImport: i0, template: `
		<ng-content />
	`, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-hover-card',
                    standalone: true,
                    providers: [BrnHoverCardContentService],
                    template: `
		<ng-content />
	`,
                }]
        }], propDecorators: { _trigger: [{
                type: ContentChild,
                args: [BrnHoverCardTriggerDirective, { static: true }]
            }], _content: [{
                type: ContentChild,
                args: [BrnHoverCardContentDirective, { static: true }]
            }] } });

const BrnHoverCardImports = [
    BrnHoverCardComponent,
    BrnHoverCardContentDirective,
    BrnHoverCardTriggerDirective,
];
class BrnHoverCardModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardModule, imports: [BrnHoverCardComponent,
            BrnHoverCardContentDirective,
            BrnHoverCardTriggerDirective], exports: [BrnHoverCardComponent,
            BrnHoverCardContentDirective,
            BrnHoverCardTriggerDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnHoverCardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnHoverCardImports],
                    exports: [...BrnHoverCardImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnHoverCardComponent, BrnHoverCardContentDirective, BrnHoverCardContentService, BrnHoverCardImports, BrnHoverCardModule, BrnHoverCardTriggerDirective, createHoverObservable };
//# sourceMappingURL=spartan-ng-ui-hovercard-brain.mjs.map
