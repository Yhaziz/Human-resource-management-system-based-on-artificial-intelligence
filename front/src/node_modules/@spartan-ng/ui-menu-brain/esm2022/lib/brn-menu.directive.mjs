import { CdkMenu } from '@angular/cdk/menu';
import { Directive, inject, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/menu";
export class BrnMenuDirective {
    constructor() {
        this._host = inject(CdkMenu);
        this._state = signal('open');
        this._side = signal('top');
        this.setSideWithDarkMagic();
        // this is a best effort, but does not seem to work currently
        // TODO: figure out a way for us to know the host is about to be closed. might not be possible with CDK
        this._host.closed.pipe(takeUntilDestroyed()).subscribe(() => this._state.set('closed'));
    }
    setSideWithDarkMagic() {
        /**
         * This is an ugly workaround to at least figure out the correct side of where a submenu
         * will appear and set the attribute to the host accordingly
         *
         * First of all we take advantage of the menu stack not being aware of the root
         * object immediately after it is added. This code executes before the root element is added,
         * which means the stack is still empty and the peek method returns undefined.
         */
        const isRoot = this._host.menuStack.peek() === undefined;
        setTimeout(() => {
            // our menu trigger directive leaves the last position used for use immediately after opening
            // we can access it here and determine the correct side.
            // eslint-disable-next-line
            const ps = this._host._parentTrigger._spartanLastPosition;
            const side = isRoot ? ps.originY : ps.originX === 'end' ? 'right' : 'left';
            this._side.set(side);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnMenuDirective, isStandalone: true, selector: "[brnMenu],[brnSubMenu]", host: { properties: { "attr.data-state": "_state()", "attr.data-side": "_side()" } }, hostDirectives: [{ directive: i1.CdkMenu }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenu],[brnSubMenu]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': '_state()',
                        '[attr.data-side]': '_side()',
                    },
                    hostDirectives: [CdkMenu],
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJuLW1lbnUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy91aS9tZW51L2JyYWluL3NyYy9saWIvYnJuLW1lbnUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM1QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7OztBQVdoRSxNQUFNLE9BQU8sZ0JBQWdCO0lBTTVCO1FBTGlCLFVBQUssR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdEIsV0FBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4QixVQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBR3hDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQzVCLDZEQUE2RDtRQUM3RCx1R0FBdUc7UUFDdkcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBRU8sb0JBQW9CO1FBQzNCOzs7Ozs7O1dBT0c7UUFDSCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxTQUFTLENBQUM7UUFDekQsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNmLDZGQUE2RjtZQUM3Rix3REFBd0Q7WUFDeEQsMkJBQTJCO1lBQzNCLE1BQU0sRUFBRSxHQUFJLElBQUksQ0FBQyxLQUFhLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDO1lBQ25FLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQzNFLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQzs4R0EvQlcsZ0JBQWdCO2tHQUFoQixnQkFBZ0I7OzJGQUFoQixnQkFBZ0I7a0JBVDVCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLHdCQUF3QjtvQkFDbEMsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLElBQUksRUFBRTt3QkFDTCxtQkFBbUIsRUFBRSxVQUFVO3dCQUMvQixrQkFBa0IsRUFBRSxTQUFTO3FCQUM3QjtvQkFDRCxjQUFjLEVBQUUsQ0FBQyxPQUFPLENBQUM7aUJBQ3pCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrTWVudSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9tZW51JztcbmltcG9ydCB7IERpcmVjdGl2ZSwgaW5qZWN0LCBzaWduYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbERlc3Ryb3llZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcblxuQERpcmVjdGl2ZSh7XG5cdHNlbGVjdG9yOiAnW2Jybk1lbnVdLFticm5TdWJNZW51XScsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdGhvc3Q6IHtcblx0XHQnW2F0dHIuZGF0YS1zdGF0ZV0nOiAnX3N0YXRlKCknLFxuXHRcdCdbYXR0ci5kYXRhLXNpZGVdJzogJ19zaWRlKCknLFxuXHR9LFxuXHRob3N0RGlyZWN0aXZlczogW0Nka01lbnVdLFxufSlcbmV4cG9ydCBjbGFzcyBCcm5NZW51RGlyZWN0aXZlIHtcblx0cHJpdmF0ZSByZWFkb25seSBfaG9zdCA9IGluamVjdChDZGtNZW51KTtcblxuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRlID0gc2lnbmFsKCdvcGVuJyk7XG5cdHByb3RlY3RlZCByZWFkb25seSBfc2lkZSA9IHNpZ25hbCgndG9wJyk7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5zZXRTaWRlV2l0aERhcmtNYWdpYygpO1xuXHRcdC8vIHRoaXMgaXMgYSBiZXN0IGVmZm9ydCwgYnV0IGRvZXMgbm90IHNlZW0gdG8gd29yayBjdXJyZW50bHlcblx0XHQvLyBUT0RPOiBmaWd1cmUgb3V0IGEgd2F5IGZvciB1cyB0byBrbm93IHRoZSBob3N0IGlzIGFib3V0IHRvIGJlIGNsb3NlZC4gbWlnaHQgbm90IGJlIHBvc3NpYmxlIHdpdGggQ0RLXG5cdFx0dGhpcy5faG9zdC5jbG9zZWQucGlwZSh0YWtlVW50aWxEZXN0cm95ZWQoKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3N0YXRlLnNldCgnY2xvc2VkJykpO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRTaWRlV2l0aERhcmtNYWdpYygpIHtcblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIGFuIHVnbHkgd29ya2Fyb3VuZCB0byBhdCBsZWFzdCBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IHNpZGUgb2Ygd2hlcmUgYSBzdWJtZW51XG5cdFx0ICogd2lsbCBhcHBlYXIgYW5kIHNldCB0aGUgYXR0cmlidXRlIHRvIHRoZSBob3N0IGFjY29yZGluZ2x5XG5cdFx0ICpcblx0XHQgKiBGaXJzdCBvZiBhbGwgd2UgdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIG1lbnUgc3RhY2sgbm90IGJlaW5nIGF3YXJlIG9mIHRoZSByb290XG5cdFx0ICogb2JqZWN0IGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIGFkZGVkLiBUaGlzIGNvZGUgZXhlY3V0ZXMgYmVmb3JlIHRoZSByb290IGVsZW1lbnQgaXMgYWRkZWQsXG5cdFx0ICogd2hpY2ggbWVhbnMgdGhlIHN0YWNrIGlzIHN0aWxsIGVtcHR5IGFuZCB0aGUgcGVlayBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG5cdFx0ICovXG5cdFx0Y29uc3QgaXNSb290ID0gdGhpcy5faG9zdC5tZW51U3RhY2sucGVlaygpID09PSB1bmRlZmluZWQ7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyBvdXIgbWVudSB0cmlnZ2VyIGRpcmVjdGl2ZSBsZWF2ZXMgdGhlIGxhc3QgcG9zaXRpb24gdXNlZCBmb3IgdXNlIGltbWVkaWF0ZWx5IGFmdGVyIG9wZW5pbmdcblx0XHRcdC8vIHdlIGNhbiBhY2Nlc3MgaXQgaGVyZSBhbmQgZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHNpZGUuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblx0XHRcdGNvbnN0IHBzID0gKHRoaXMuX2hvc3QgYXMgYW55KS5fcGFyZW50VHJpZ2dlci5fc3BhcnRhbkxhc3RQb3NpdGlvbjtcblx0XHRcdGNvbnN0IHNpZGUgPSBpc1Jvb3QgPyBwcy5vcmlnaW5ZIDogcHMub3JpZ2luWCA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuXHRcdFx0dGhpcy5fc2lkZS5zZXQoc2lkZSk7XG5cdFx0fSk7XG5cdH1cbn1cbiJdfQ==