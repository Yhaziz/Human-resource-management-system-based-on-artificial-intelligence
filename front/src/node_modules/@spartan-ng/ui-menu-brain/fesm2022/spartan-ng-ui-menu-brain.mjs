import * as i0 from '@angular/core';
import { inject, signal, effect, Directive, Input, booleanAttribute, Output, NgModule } from '@angular/core';
import * as i1 from '@angular/cdk/menu';
import { CdkContextMenuTrigger, CdkMenuBar, CdkMenuGroup, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItem, CdkMenuTrigger, CdkMenu } from '@angular/cdk/menu';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

class BrnContextMenuTriggerDirective {
    set align(value) {
        this._align.set(value);
    }
    set brnCtxMenuTriggerFor(value) {
        this._cdkTrigger.menuTemplateRef = value;
    }
    constructor() {
        this._cdkTrigger = inject(CdkContextMenuTrigger, { host: true });
        this._align = signal(undefined);
        // once the trigger opens we wait until the next tick and then grab the last position
        // used to position the menu. we store this in our trigger which the brnMenu directive has
        // access to through DI
        this._cdkTrigger.opened.pipe(takeUntilDestroyed()).subscribe(() => setTimeout(() => 
        // eslint-disable-next-line
        (this._cdkTrigger['_spartanLastPosition'] = // eslint-disable-next-line
            this._cdkTrigger.overlayRef._positionStrategy._lastPosition)));
        effect(() => {
            const align = this._align();
            if (!align)
                return;
            this._cdkTrigger.menuPosition = [
                {
                    originX: align,
                    originY: 'bottom',
                    overlayX: align,
                    overlayY: 'top',
                },
                {
                    originX: align,
                    originY: 'top',
                    overlayX: align,
                    overlayY: 'bottom',
                },
            ];
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnContextMenuTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnContextMenuTriggerDirective, isStandalone: true, selector: "[brnCtxMenuTriggerFor]", inputs: { align: "align", brnCtxMenuTriggerFor: "brnCtxMenuTriggerFor" }, hostDirectives: [{ directive: i1.CdkContextMenuTrigger }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnContextMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCtxMenuTriggerFor]',
                    standalone: true,
                    hostDirectives: [CdkContextMenuTrigger],
                }]
        }], ctorParameters: () => [], propDecorators: { align: [{
                type: Input
            }], brnCtxMenuTriggerFor: [{
                type: Input
            }] } });

class BrnMenuBarDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuBarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnMenuBarDirective, isStandalone: true, selector: "[brnMenuBar]", hostDirectives: [{ directive: i1.CdkMenuBar }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuBar]',
                    standalone: true,
                    hostDirectives: [CdkMenuBar],
                }]
        }] });

class BrnMenuGroupDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnMenuGroupDirective, isStandalone: true, selector: "[brnMenuGroup]", hostDirectives: [{ directive: i1.CdkMenuGroup }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuGroup]',
                    standalone: true,
                    hostDirectives: [CdkMenuGroup],
                }]
        }] });

class BrnMenuItemCheckboxDirective {
    constructor() {
        this._cdkMenuItem = inject(CdkMenuItemCheckbox, { host: true });
        this._checked = signal(this._cdkMenuItem.checked);
        this._disabled = signal(this._cdkMenuItem.disabled);
        this.triggered = this._cdkMenuItem.triggered;
    }
    set checked(value) {
        this._cdkMenuItem.checked = value;
        this._checked.set(value);
    }
    get checked() {
        return this._checked();
    }
    set disabled(value) {
        this._cdkMenuItem.disabled = value;
        this._disabled.set(value);
    }
    get disabled() {
        return this._disabled();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemCheckboxDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.5", type: BrnMenuItemCheckboxDirective, isStandalone: true, selector: "[brnMenuItemCheckbox]", inputs: { checked: ["checked", "checked", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { triggered: "triggered" }, host: { properties: { "class.checked": "_checked()", "disabled": "_disabled()" } }, hostDirectives: [{ directive: i1.CdkMenuItemCheckbox }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuItemCheckbox]',
                    standalone: true,
                    hostDirectives: [CdkMenuItemCheckbox],
                    host: {
                        '[class.checked]': '_checked()',
                        '[disabled]': '_disabled()',
                    },
                }]
        }], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], triggered: [{
                type: Output
            }] } });

class BrnMenuItemRadioDirective {
    constructor() {
        this._cdkMenuItem = inject(CdkMenuItemRadio, { host: true });
        this._checked = signal(this._cdkMenuItem.checked);
        this._disabled = signal(this._cdkMenuItem.disabled);
        this.triggered = this._cdkMenuItem.triggered;
    }
    set checked(value) {
        this._cdkMenuItem.checked = value;
        this._checked.set(value);
    }
    get checked() {
        return this._checked();
    }
    set disabled(value) {
        this._cdkMenuItem.disabled = value;
        this._disabled.set(value);
    }
    get disabled() {
        return this._disabled();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemRadioDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.5", type: BrnMenuItemRadioDirective, isStandalone: true, selector: "[brnMenuItemRadio]", inputs: { checked: ["checked", "checked", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { triggered: "triggered" }, host: { properties: { "class.checked": "_checked()", "disabled": "_disabled()" } }, hostDirectives: [{ directive: i1.CdkMenuItemRadio }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemRadioDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuItemRadio]',
                    standalone: true,
                    hostDirectives: [CdkMenuItemRadio],
                    host: {
                        '[class.checked]': '_checked()',
                        '[disabled]': '_disabled()',
                    },
                }]
        }], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], triggered: [{
                type: Output
            }] } });

class BrnMenuItemDirective {
    constructor() {
        this._cdkMenuItem = inject(CdkMenuItem, { host: true });
        this._disabled = signal(this._cdkMenuItem.disabled);
        this.triggered = this._cdkMenuItem.triggered;
    }
    set disabled(value) {
        this._cdkMenuItem.disabled = value;
        this._disabled.set(value);
    }
    get disabled() {
        return this._disabled();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.5", type: BrnMenuItemDirective, isStandalone: true, selector: "[brnMenuItem]", inputs: { disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { triggered: "triggered" }, host: { properties: { "disabled": "_disabled()" } }, hostDirectives: [{ directive: i1.CdkMenuItem }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuItem]',
                    standalone: true,
                    hostDirectives: [CdkMenuItem],
                    host: {
                        '[disabled]': '_disabled()',
                    },
                }]
        }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], triggered: [{
                type: Output
            }] } });

class BrnMenuTriggerDirective {
    set align(value) {
        this._align.set(value);
    }
    constructor() {
        this._cdkTrigger = inject(CdkMenuTrigger, { host: true });
        this._align = signal(undefined);
        // once the trigger opens we wait until the next tick and then grab the last position
        // used to position the menu. we store this in our trigger which the brnMenu directive has
        // access to through DI
        this._cdkTrigger.opened.pipe(takeUntilDestroyed()).subscribe(() => setTimeout(() => 
        // eslint-disable-next-line
        (this._cdkTrigger['_spartanLastPosition'] = // eslint-disable-next-line
            this._cdkTrigger.overlayRef._positionStrategy._lastPosition)));
        effect(() => {
            const align = this._align();
            if (!align)
                return;
            this._cdkTrigger.menuPosition = [
                {
                    originX: align,
                    originY: 'bottom',
                    overlayX: align,
                    overlayY: 'top',
                },
                {
                    originX: align,
                    originY: 'top',
                    overlayX: align,
                    overlayY: 'bottom',
                },
            ];
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnMenuTriggerDirective, isStandalone: true, selector: "[brnMenuTriggerFor]", inputs: { align: "align" }, hostDirectives: [{ directive: i1.CdkMenuTrigger, inputs: ["cdkMenuTriggerFor", "brnMenuTriggerFor"] }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuTriggerFor]',
                    standalone: true,
                    hostDirectives: [{ directive: CdkMenuTrigger, inputs: ['cdkMenuTriggerFor: brnMenuTriggerFor'] }],
                }]
        }], ctorParameters: () => [], propDecorators: { align: [{
                type: Input
            }] } });

class BrnMenuDirective {
    constructor() {
        this._host = inject(CdkMenu);
        this._state = signal('open');
        this._side = signal('top');
        this.setSideWithDarkMagic();
        // this is a best effort, but does not seem to work currently
        // TODO: figure out a way for us to know the host is about to be closed. might not be possible with CDK
        this._host.closed.pipe(takeUntilDestroyed()).subscribe(() => this._state.set('closed'));
    }
    setSideWithDarkMagic() {
        /**
         * This is an ugly workaround to at least figure out the correct side of where a submenu
         * will appear and set the attribute to the host accordingly
         *
         * First of all we take advantage of the menu stack not being aware of the root
         * object immediately after it is added. This code executes before the root element is added,
         * which means the stack is still empty and the peek method returns undefined.
         */
        const isRoot = this._host.menuStack.peek() === undefined;
        setTimeout(() => {
            // our menu trigger directive leaves the last position used for use immediately after opening
            // we can access it here and determine the correct side.
            // eslint-disable-next-line
            const ps = this._host._parentTrigger._spartanLastPosition;
            const side = isRoot ? ps.originY : ps.originX === 'end' ? 'right' : 'left';
            this._side.set(side);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnMenuDirective, isStandalone: true, selector: "[brnMenu],[brnSubMenu]", host: { properties: { "attr.data-state": "_state()", "attr.data-side": "_side()" } }, hostDirectives: [{ directive: i1.CdkMenu }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenu],[brnSubMenu]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': '_state()',
                        '[attr.data-side]': '_side()',
                    },
                    hostDirectives: [CdkMenu],
                }]
        }], ctorParameters: () => [] });

const BrnMenuItemImports = [
    BrnMenuGroupDirective,
    BrnMenuItemDirective,
    BrnMenuItemRadioDirective,
    BrnMenuItemCheckboxDirective,
];
const BrnMenuImports = [BrnMenuTriggerDirective, BrnMenuDirective, ...BrnMenuItemImports];
const BrnMenuBarImports = [...BrnMenuImports, BrnMenuBarDirective];
const BrnContextMenuImports = [...BrnMenuImports, BrnContextMenuTriggerDirective];
class BrnMenuItemModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemModule, imports: [BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective], exports: [BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuItemModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnMenuItemImports],
                    exports: [...BrnMenuItemImports],
                }]
        }] });
class BrnMenuModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuModule, imports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective], exports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnMenuImports],
                    exports: [...BrnMenuImports],
                }]
        }] });
class BrnMenuBarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuBarModule, imports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnMenuBarDirective], exports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnMenuBarDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuBarModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnMenuBarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnMenuBarImports],
                    exports: [...BrnMenuBarImports],
                }]
        }] });
class BrnContextMenuModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnContextMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnContextMenuModule, imports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnContextMenuTriggerDirective], exports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnContextMenuTriggerDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnContextMenuModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnContextMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnContextMenuImports],
                    exports: [...BrnContextMenuImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnContextMenuImports, BrnContextMenuModule, BrnContextMenuTriggerDirective, BrnMenuBarDirective, BrnMenuBarImports, BrnMenuBarModule, BrnMenuDirective, BrnMenuGroupDirective, BrnMenuImports, BrnMenuItemCheckboxDirective, BrnMenuItemDirective, BrnMenuItemImports, BrnMenuItemModule, BrnMenuItemRadioDirective, BrnMenuModule, BrnMenuTriggerDirective };
//# sourceMappingURL=spartan-ng-ui-menu-brain.mjs.map
