import * as i0 from '@angular/core';
import { inject, ElementRef, ChangeDetectorRef, EventEmitter, booleanAttribute, numberAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, ViewChild, forwardRef, ContentChildren, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { FocusMonitor } from '@angular/cdk/a11y';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';

class BrnRadioChange {
    constructor(source, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    value) {
        this.source = source;
        this.value = value;
    }
}

let nextUniqueId$1 = 0;
class BrnRadioComponent {
    constructor() {
        this._focusMonitor = inject(FocusMonitor);
        this._elementRef = inject(ElementRef);
        this._radioDispatcher = inject(UniqueSelectionDispatcher);
        this._changeDetector = inject(ChangeDetectorRef);
        this.radioGroup = inject(BrnRadioGroupComponent, { optional: true });
        this._disabled = false;
        this._defaultTabIndex = 0;
        this._tabIndex = 0;
        this._uniqueId = `brn-radio-${++nextUniqueId$1}`;
        this.id = this._uniqueId;
        // will be overwritten with radio group name if group exists
        this.name = this._uniqueId;
        this._checked = false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._value = null;
        this._required = false;
        this.change = new EventEmitter();
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._removeUniqueSelectionListener = () => { };
    }
    get disabled() {
        return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);
    }
    set disabled(value) {
        this._setDisabled(value);
    }
    set defaultTabIndex(value) {
        this._defaultTabIndex = value;
    }
    get tabIndex() {
        return this.disabled ? -1 : this._tabIndex;
    }
    set tabIndex(value) {
        this._tabIndex = value != null ? value : this._defaultTabIndex;
    }
    get checked() {
        return this._checked;
    }
    set checked(value) {
        const newCheckedState = value;
        if (this._checked !== newCheckedState) {
            this._checked = newCheckedState;
            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {
                this.radioGroup.selected = this;
            }
            else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {
                // When unchecking the selected radio button, update the selected radio
                // property on the group.
                this.radioGroup.selected = null;
            }
            if (newCheckedState) {
                // Notify all radio buttons with the same name to un-check.
                this._radioDispatcher.notify(this.id, this.name);
            }
            this._changeDetector.markForCheck();
        }
    }
    get value() {
        return this._value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            if (this.radioGroup !== null) {
                if (!this.checked) {
                    // Update checked when the value changed to match the radio group's value
                    this.checked = this.radioGroup.value === value;
                }
                if (this.checked) {
                    this.radioGroup.selected = this;
                }
            }
        }
    }
    get required() {
        return this._required || (this.radioGroup !== null && this.radioGroup.required);
    }
    set required(value) {
        this._required = value;
    }
    get inputId() {
        return `${this.id || this._uniqueId}-input`;
    }
    /** Focuses the radio button. */
    focus(origin) {
        if (!this._inputElement)
            return;
        if (origin) {
            this._focusMonitor.focusVia(this._inputElement, origin);
        }
        else {
            this._inputElement.nativeElement.focus();
        }
    }
    _markForCheck() {
        this._changeDetector.markForCheck();
    }
    ngOnInit() {
        if (this.radioGroup) {
            // If the radio is inside a radio group, determine if it should be checked
            this.checked = this.radioGroup.value === this._value;
            if (this.checked) {
                this.radioGroup.selected = this;
            }
            // Copy name from parent radio group
            this.name = this.radioGroup.name;
        }
        this._removeUniqueSelectionListener = this._radioDispatcher.listen((id, name) => {
            if (id !== this.id && name === this.name) {
                this.checked = false;
            }
        });
    }
    ngDoCheck() {
        this._updateTabIndex();
    }
    ngAfterViewInit() {
        this._updateTabIndex();
        this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
            if (!focusOrigin && this.radioGroup) {
                this.radioGroup._touch();
            }
        });
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
        this._removeUniqueSelectionListener();
    }
    /** Dispatch change event with current value. */
    _emitChangeEvent() {
        this.change.emit(new BrnRadioChange(this, this._value));
    }
    _onInputClick(event) {
        // We have to stop propagation for click events on the visual hidden input element.
        // By default, when a user clicks on a label element, a generated click event will be
        // dispatched on the associated input element. Since we are using a label element as our
        // root container, the click event on the `radio-button` will be executed twice.
        // The real click event will bubble up, and the generated click event also tries to bubble up.
        // This will lead to multiple click events.
        // Preventing bubbling for the second event will solve that issue.
        event.stopPropagation();
    }
    _onInputInteraction(event) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        event.stopPropagation();
        if (!this.checked && !this.disabled) {
            const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;
            this.checked = true;
            this._emitChangeEvent();
            if (this.radioGroup) {
                this.radioGroup._controlValueAccessorChangeFn(this.value);
                if (groupValueChanged) {
                    this.radioGroup._emitChangeEvent();
                }
            }
        }
    }
    /** Triggered when the user clicks on the touch target. */
    _onTouchTargetClick(event) {
        this._onInputInteraction(event);
        if (!this.disabled && this._inputElement) {
            // Normally the input should be focused already, but if the click
            // comes from the touch target, then we might have to focus it ourselves.
            this._inputElement.nativeElement.focus();
        }
    }
    _setDisabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
            this._changeDetector.markForCheck();
        }
    }
    _updateTabIndex() {
        const group = this.radioGroup;
        let value;
        // Implement a roving tabindex if the button is inside a group. For most cases this isn't
        // necessary, because the browser handles the tab order for inputs inside a group automatically,
        // but we need an explicitly higher tabindex for the selected button in order for things like
        // the focus trap to pick it up correctly.
        if (!group || !group.selected || this.disabled) {
            value = this.tabIndex;
        }
        else {
            value = group.selected === this ? this.tabIndex : -1;
        }
        if (value !== this._previousTabIndex) {
            // We have to set the tabindex directly on the DOM node, because it depends on
            // the selected state which is prone to "changed after checked errors".
            const input = this._inputElement?.nativeElement;
            if (input) {
                input.setAttribute('tabindex', value + '');
                this._previousTabIndex = value;
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.5", type: BrnRadioComponent, isStandalone: true, selector: "brn-radio", inputs: { disabled: ["disabled", "disabled", booleanAttribute], defaultTabIndex: ["defaultTabIndex", "defaultTabIndex", numberAttribute], tabIndex: ["tabIndex", "tabIndex", numberAttribute], id: "id", name: "name", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], checked: ["checked", "checked", booleanAttribute], value: "value", required: ["required", "required", booleanAttribute] }, outputs: { change: "change" }, host: { listeners: { "focus": "_inputElement.nativeElement.focus()" }, properties: { "attr.id": "id", "class.brn-radio-checked": "checked", "class.brn-radio-disabled": "disabled", "attr.data-checked": "checked", "attr.data-disabled": "disabled", "attr.data-value": "value", "attr.tabindex": "null", "attr.aria-label": "null", "attr.aria-labelledby": "null", "attr.aria-describedby": "null" }, classAttribute: "brn-radio" }, viewQueries: [{ propertyName: "_inputElement", first: true, predicate: ["input"], descendants: true }], exportAs: ["brnRadio"], ngImport: i0, template: `
		<div style="display: flex; height: fit-content; width: fit-content" (click)="_onTouchTargetClick($event)">
			<ng-content select="[target],[indicator]" />
		</div>
		<input
			#input
			style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;"
			type="radio"
			[id]="inputId"
			[checked]="checked"
			[disabled]="disabled"
			[attr.name]="name"
			[attr.value]="value"
			[required]="required"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-describedby]="ariaDescribedby"
			(change)="_onInputInteraction($event)"
			(click)="_onInputClick($event)"
		/>
		<label style="display: flex; height: fit-content; width: fit-content" [for]="inputId">
			<ng-content></ng-content>
		</label>
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-radio',
                    standalone: true,
                    imports: [],
                    host: {
                        class: 'brn-radio',
                        '[attr.id]': 'id',
                        '[class.brn-radio-checked]': 'checked',
                        '[class.brn-radio-disabled]': 'disabled',
                        '[attr.data-checked]': 'checked',
                        '[attr.data-disabled]': 'disabled',
                        '[attr.data-value]': 'value',
                        // Needs to be removed since it causes some a11y issues (see #21266).
                        '[attr.tabindex]': 'null',
                        '[attr.aria-label]': 'null',
                        '[attr.aria-labelledby]': 'null',
                        '[attr.aria-describedby]': 'null',
                        // Note: under normal conditions focus shouldn't land on this element, however it may be
                        // programmatically set, for example inside of a focus trap, in this case we want to forward
                        // the focus to the native element.
                        '(focus)': '_inputElement.nativeElement.focus()',
                    },
                    exportAs: 'brnRadio',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
		<div style="display: flex; height: fit-content; width: fit-content" (click)="_onTouchTargetClick($event)">
			<ng-content select="[target],[indicator]" />
		</div>
		<input
			#input
			style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;"
			type="radio"
			[id]="inputId"
			[checked]="checked"
			[disabled]="disabled"
			[attr.name]="name"
			[attr.value]="value"
			[required]="required"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-describedby]="ariaDescribedby"
			(change)="_onInputInteraction($event)"
			(click)="_onInputClick($event)"
		/>
		<label style="display: flex; height: fit-content; width: fit-content" [for]="inputId">
			<ng-content></ng-content>
		</label>
	`,
                }]
        }], propDecorators: { disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], defaultTabIndex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], tabIndex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], id: [{
                type: Input
            }], name: [{
                type: Input
            }], ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }], ariaLabelledby: [{
                type: Input,
                args: ['aria-labelledby']
            }], ariaDescribedby: [{
                type: Input,
                args: ['aria-describedby']
            }], checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input,
                args: [{ required: true }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], change: [{
                type: Output
            }], _inputElement: [{
                type: ViewChild,
                args: ['input']
            }] } });

let nextUniqueId = 0;
const BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnRadioGroupComponent),
    multi: true,
};
class BrnRadioGroupComponent {
    constructor() {
        this._changeDetector = inject(ChangeDetectorRef);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._value = null;
        this._isInitialized = false;
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-explicit-any
        this._controlValueAccessorChangeFn = () => { };
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-explicit-any
        this.onTouched = () => { };
        this._name = `brn-radio-group-${nextUniqueId++}`;
        /**
         * The currently selected radio button. If set to a new radio button, the radio group value
         * will be updated to match the new selected button.
         */
        this._selected = null;
        this._disabled = false;
        this._required = false;
        this.direction = 'ltr';
        this.change = new EventEmitter();
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        this._updateRadioButtonNames();
    }
    /**
     * Value for the radio-group. Should equal the value of the selected radio button if there is
     * a corresponding radio button with a matching value. If there is not such a corresponding
     * radio button, this value persists to be applied in case a new radio button is added with a
     * matching value.
     */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    set value(newValue) {
        if (this._value !== newValue) {
            // Set this before proceeding to ensure no circular loop occurs with selection.
            this._value = newValue;
            this._updateSelectedRadioFromValue();
            this._checkSelectedRadioButton();
        }
    }
    _checkSelectedRadioButton() {
        if (this._selected && !this._selected.checked) {
            this._selected.checked = true;
        }
    }
    get selected() {
        return this._selected;
    }
    set selected(selected) {
        this._selected = selected;
        this.value = selected ? selected.value : null;
        this._checkSelectedRadioButton();
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
        this._markRadiosForCheck();
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
        this._markRadiosForCheck();
    }
    /**
     * Initialize properties once content children are available.
     * This allows us to propagate relevant attributes to associated buttons.
     */
    ngAfterContentInit() {
        // Mark this component as initialized in AfterContentInit because the initial value can
        // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the
        // NgModel occurs *after* the OnInit of the MatRadioGroup.
        this._isInitialized = true;
    }
    /**
     * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
     * radio buttons upon their blur.
     */
    _touch() {
        if (this.onTouched) {
            this.onTouched();
        }
    }
    _updateRadioButtonNames() {
        if (this._radios) {
            this._radios.forEach((radio) => {
                radio.name = this.name;
                radio._markForCheck();
            });
        }
    }
    /** Updates the `selected` radio button from the internal _value state. */
    _updateSelectedRadioFromValue() {
        // If the value already matches the selected radio, do nothing.
        const isAlreadySelected = this._selected !== null && this._selected.value === this._value;
        if (this._radios && !isAlreadySelected) {
            this._selected = null;
            this._radios.forEach((radio) => {
                radio.checked = this.value === radio.value;
                if (radio.checked) {
                    this._selected = radio;
                }
            });
        }
    }
    _emitChangeEvent() {
        if (this._isInitialized) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.change.emit(new BrnRadioChange(this._selected, this._value));
        }
    }
    _markRadiosForCheck() {
        if (this._radios) {
            this._radios.forEach((radio) => radio._markForCheck());
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    writeValue(value) {
        this.value = value;
        this._changeDetector.markForCheck();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnChange(fn) {
        this._controlValueAccessorChangeFn = fn;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetector.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.5", type: BrnRadioGroupComponent, isStandalone: true, selector: "brn-radio-group", inputs: { name: "name", value: "value", selected: "selected", disabled: ["disabled", "disabled", booleanAttribute], required: ["required", "required", booleanAttribute], direction: "direction" }, outputs: { change: "change" }, host: { attributes: { "role": "radiogroup" } }, providers: [BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR], queries: [{ propertyName: "_radios", predicate: BrnRadioComponent, descendants: true }], ngImport: i0, template: `
		<ng-content />
	`, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-radio-group',
                    standalone: true,
                    providers: [BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
                    imports: [],
                    host: {
                        role: 'radiogroup',
                    },
                    template: `
		<ng-content />
	`,
                }]
        }], propDecorators: { _radios: [{
                type: ContentChildren,
                args: [BrnRadioComponent, { descendants: true }]
            }], name: [{
                type: Input
            }], value: [{
                type: Input
            }], selected: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], direction: [{
                type: Input
            }], change: [{
                type: Output
            }] } });

const BrnRadioGroupImports = [BrnRadioGroupComponent, BrnRadioComponent];
class BrnRadioGroupModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioGroupModule, imports: [BrnRadioGroupComponent, BrnRadioComponent], exports: [BrnRadioGroupComponent, BrnRadioComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioGroupModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnRadioGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnRadioGroupImports],
                    exports: [...BrnRadioGroupImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, BrnRadioChange, BrnRadioComponent, BrnRadioGroupComponent, BrnRadioGroupImports, BrnRadioGroupModule };
//# sourceMappingURL=spartan-ng-ui-radiogroup-brain.mjs.map
