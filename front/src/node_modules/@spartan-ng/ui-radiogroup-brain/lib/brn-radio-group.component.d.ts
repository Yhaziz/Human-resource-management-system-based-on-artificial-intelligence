import { EventEmitter, type AfterContentInit } from '@angular/core';
import { BrnRadioChange } from './brn-radio-change';
import { BrnRadioComponent } from './brn-radio.component';
import * as i0 from "@angular/core";
export declare const BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: {
    provide: import("@angular/core").InjectionToken<readonly import("@angular/forms").ControlValueAccessor[]>;
    useExisting: import("@angular/core").Type<any>;
    multi: boolean;
};
export declare class BrnRadioGroupComponent implements AfterContentInit {
    private _changeDetector;
    private _value;
    private _isInitialized;
    private _radios?;
    _controlValueAccessorChangeFn: (value: any) => void;
    onTouched: () => any;
    private _name;
    get name(): string;
    set name(value: string);
    /**
     * Value for the radio-group. Should equal the value of the selected radio button if there is
     * a corresponding radio button with a matching value. If there is not such a corresponding
     * radio button, this value persists to be applied in case a new radio button is added with a
     * matching value.
     */
    get value(): any;
    set value(newValue: any);
    _checkSelectedRadioButton(): void;
    /**
     * The currently selected radio button. If set to a new radio button, the radio group value
     * will be updated to match the new selected button.
     */
    private _selected;
    get selected(): BrnRadioComponent | null;
    set selected(selected: BrnRadioComponent | null);
    private _disabled;
    get disabled(): boolean;
    set disabled(value: boolean);
    private _required;
    get required(): boolean;
    set required(value: boolean);
    direction: 'ltr' | 'rtl' | null;
    readonly change: EventEmitter<BrnRadioChange>;
    /**
     * Initialize properties once content children are available.
     * This allows us to propagate relevant attributes to associated buttons.
     */
    ngAfterContentInit(): void;
    /**
     * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
     * radio buttons upon their blur.
     */
    _touch(): void;
    private _updateRadioButtonNames;
    /** Updates the `selected` radio button from the internal _value state. */
    private _updateSelectedRadioFromValue;
    _emitChangeEvent(): void;
    _markRadiosForCheck(): void;
    writeValue(value: any): void;
    registerOnChange(fn: (value: any) => void): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnRadioGroupComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BrnRadioGroupComponent, "brn-radio-group", never, { "name": { "alias": "name"; "required": false; }; "value": { "alias": "value"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "required": { "alias": "required"; "required": false; }; "direction": { "alias": "direction"; "required": false; }; }, { "change": "change"; }, ["_radios"], ["*"], true, never>;
    static ngAcceptInputType_disabled: unknown;
    static ngAcceptInputType_required: unknown;
}
