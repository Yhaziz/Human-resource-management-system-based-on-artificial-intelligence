import * as i0 from '@angular/core';
import { signal, computed, Injectable, inject, ElementRef, Directive, Input, DestroyRef, effect, Component, ChangeDetectionStrategy, ViewChild, ContentChild, ContentChildren, input, EventEmitter, Output, NgModule } from '@angular/core';
import * as i1 from '@angular/cdk/listbox';
import { CdkOption, CdkListbox, CdkListboxModule } from '@angular/cdk/listbox';
import { NgTemplateOutlet, JsonPipe } from '@angular/common';
import { toObservable, takeUntilDestroyed, toSignal } from '@angular/core/rxjs-interop';
import { Subject, skip, fromEvent, interval, takeUntil, switchMap, of, delay, map } from 'rxjs';
import * as i1$1 from '@spartan-ng/ui-label-brain';
import { BrnLabelDirective } from '@spartan-ng/ui-label-brain';
import { NgControl } from '@angular/forms';
import * as i1$2 from '@angular/cdk/overlay';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { provideExposedSideProviderExisting, provideExposesStateProviderExisting } from '@spartan-ng/ui-core';

class BrnSelectService {
    get selectTrigger() {
        return this._selectTrigger;
    }
    constructor() {
        this.state = signal({
            id: '',
            labelId: '',
            panelId: '',
            placeholder: '',
            isExpanded: false,
            multiple: false,
            disabled: false,
            dir: 'ltr',
            selectedOptions: [],
            initialSelectedOptions: [],
            value: '',
            triggerWidth: 0,
        });
        this.id = computed(() => this.state().id);
        this.labelId = computed(() => this.state().labelId);
        this.panelId = computed(() => this.state().panelId);
        this.placeholder = computed(() => this.state().placeholder);
        this.disabled = computed(() => this.state().disabled);
        this.isExpanded = computed(() => this.state().isExpanded);
        this.multiple = computed(() => this.state().multiple);
        this.dir = computed(() => this.state().dir);
        this.selectedOptions = computed(() => this.state().selectedOptions);
        this.initialSelectedOptions = computed(() => this.state().initialSelectedOptions);
        this.value = computed(() => this.state().value);
        this.triggerWidth = computed(() => this.state().triggerWidth);
        this.possibleOptions = computed(() => this._possibleOptions());
        this._possibleOptions = signal([]);
        this.multiple$ = toObservable(this.multiple);
        this.listBoxValueChangeEvent$ = new Subject();
        this.listBoxValueChangeEvent$.pipe(takeUntilDestroyed()).subscribe((listBoxChange) => {
            const updatedSelections = this.multiple() ? this.getUpdatedOptions(listBoxChange) : [listBoxChange.option];
            const value = this.multiple() ? listBoxChange.value : listBoxChange.value[0];
            this.state.update((state) => ({
                ...state,
                selectedOptions: [...updatedSelections],
                value: value,
            }));
        });
        // We need to skip the first value because we don't want to deselect all options when the component is initialized with a preselected value e.g. by the form control
        this.multiple$.pipe(skip(1), takeUntilDestroyed()).subscribe((multiple) => {
            if (!multiple && this.value().length > 1) {
                this.deselectAllOptions();
            }
        });
    }
    setTriggerWidth(triggerWidth) {
        this.state.update((s) => ({ ...s, triggerWidth }));
    }
    getUpdatedOptions(latestListboxChange) {
        const isNewSelection = latestListboxChange.value.findIndex((value) => value === latestListboxChange.option?.value);
        if (isNewSelection === -1) {
            const removedOptionIndex = this.selectedOptions().findIndex((option) => latestListboxChange.option === option);
            const options = this.selectedOptions();
            options.splice(removedOptionIndex, 1);
            return options;
        }
        return [...this.selectedOptions(), latestListboxChange.option];
    }
    deselectAllOptions() {
        this.state.update((state) => ({
            ...state,
            selectedOptions: [],
            value: [],
        }));
    }
    // Needed due to https://github.com/angular/angular/issues/20810
    _setSelectTrigger(trigger) {
        this._selectTrigger = trigger;
    }
    registerOption(option) {
        this._possibleOptions.update((options) => [...options, option]);
    }
    deregisterOption(option) {
        this._possibleOptions.update((options) => options.filter((o) => o !== option));
    }
    setInitialSelectedOptions(value) {
        this.selectOptionByValue(value);
        this.state.update((state) => ({
            ...state,
            initialSelectedOptions: this.selectedOptions(),
        }));
    }
    selectOptionByValue(value) {
        if (value === null || value === undefined) {
            this.state.update((state) => ({
                ...state,
                selectedOptions: [],
                value: this.multiple() ? [] : '',
            }));
            return;
        }
        const options = this._possibleOptions();
        if (this.multiple()) {
            const selectedOptions = options.filter((option) => {
                if (Array.isArray(value)) {
                    return value.includes(option?.value);
                }
                return value === option?.value;
            });
            this.state.update((state) => ({
                ...state,
                selectedOptions,
                value: value,
            }));
        }
        else {
            const selectedOption = options.find((option) => option?.value === value);
            if (!selectedOption) {
                return;
            }
            this.state.update((state) => ({
                ...state,
                selectedOptions: [selectedOption],
                value: selectedOption.value,
            }));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

class BrnSelectOptionDirective {
    constructor() {
        this._cdkSelectOption = inject(CdkOption, { host: true });
        this._selectService = inject(BrnSelectService);
        this._selected = signal(false);
        this._focused = signal(false);
        this.elementRef = inject(ElementRef);
        this.selected = computed(() => this._selected());
        this.focused = computed(() => this._focused());
        this.checkedState = computed(() => (this._selected() ? 'checked' : 'unchecked'));
        this.dir = computed(() => this._selectService.dir());
        this._disabled = false;
        this._selectService.registerOption(this._cdkSelectOption);
        toObservable(this._selectService.value)
            .pipe(takeUntilDestroyed())
            .subscribe((selectedValues) => {
            if (Array.isArray(selectedValues)) {
                const itemFound = selectedValues.find((val) => val === this._cdkSelectOption.value);
                this._selected.set(!!itemFound);
            }
            else {
                this._selected.set(this._cdkSelectOption.value === selectedValues);
            }
        });
    }
    ngOnDestroy() {
        this._selectService.deregisterOption(this._cdkSelectOption);
    }
    set value(value) {
        this._cdkSelectOption.value = value;
    }
    set disabled(value) {
        this._disabled = value;
    }
    get disabled() {
        return this._disabled;
    }
    hover() {
        this.focus();
    }
    focus() {
        this._cdkSelectOption.focus();
        this._focused.set(true);
    }
    blur() {
        this._focused.set(false);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectOptionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectOptionDirective, isStandalone: true, selector: "[brnOption]", inputs: { value: "value", disabled: "disabled" }, host: { listeners: { "mouseenter": "hover()", "blur": "blur()" }, properties: { "attr.dir": "_selectService.dir()" } }, hostDirectives: [{ directive: i1.CdkOption }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectOptionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnOption]',
                    standalone: true,
                    hostDirectives: [CdkOption],
                    host: {
                        '(mouseenter)': 'hover()',
                        '(blur)': 'blur()',
                        '[attr.dir]': '_selectService.dir()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { value: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });

class BrnSelectScrollDownDirective {
    constructor() {
        this._el = inject(ElementRef);
        this._selectContent = inject(BrnSelectContentComponent);
        this.endReached = new Subject();
        this._destroyRef = inject(DestroyRef);
    }
    startEmittingEvents() {
        const mouseLeave$ = fromEvent(this._el.nativeElement, 'mouseleave');
        interval(100)
            .pipe(takeUntil(mouseLeave$), takeUntil(this.endReached), takeUntilDestroyed(this._destroyRef))
            .subscribe(() => this._selectContent.moveFocusDown());
    }
    stopEmittingEvents() {
        this.endReached.next(true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectScrollDownDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectScrollDownDirective, isStandalone: true, selector: "[brnSelectScrollDown], brn-select-scroll-down, hlm-select-scroll-down:not(noHlm)", host: { attributes: { "aria-hidden": "true" }, listeners: { "mouseenter": "startEmittingEvents()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectScrollDownDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectScrollDown], brn-select-scroll-down, hlm-select-scroll-down:not(noHlm)',
                    standalone: true,
                    host: {
                        'aria-hidden': 'true',
                        '(mouseenter)': 'startEmittingEvents()',
                    },
                }]
        }] });

class BrnSelectScrollUpDirective {
    constructor() {
        this._el = inject(ElementRef);
        this._selectContent = inject(BrnSelectContentComponent);
        this.endReached = new Subject();
        this._destroyRef = inject(DestroyRef);
    }
    startEmittingEvents() {
        const mouseLeave$ = fromEvent(this._el.nativeElement, 'mouseleave');
        interval(100)
            .pipe(takeUntil(mouseLeave$), takeUntil(this.endReached), takeUntilDestroyed(this._destroyRef))
            .subscribe(() => this._selectContent.moveFocusUp());
    }
    stopEmittingEvents() {
        this.endReached.next(true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectScrollUpDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectScrollUpDirective, isStandalone: true, selector: "[brnSelectScrollUp], brn-select-scroll-up, hlm-select-scroll-up:not(noHlm)", host: { attributes: { "aria-hidden": "true" }, listeners: { "mouseenter": "startEmittingEvents()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectScrollUpDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectScrollUp], brn-select-scroll-up, hlm-select-scroll-up:not(noHlm)',
                    standalone: true,
                    host: {
                        'aria-hidden': 'true',
                        '(mouseenter)': 'startEmittingEvents()',
                    },
                }]
        }] });

class BrnSelectContentComponent {
    constructor() {
        this._el = inject(ElementRef);
        this._cdkListbox = inject(CdkListbox, { host: true });
        this.destroyRef = inject(DestroyRef);
        this._selectService = inject(BrnSelectService);
        this.labelledBy = this._selectService.labelId;
        this.id = this._selectService.id;
        this.canScrollUp = signal(false);
        this.canScrollDown = signal(false);
        this.initialSelectedOptions$ = toObservable(this._selectService.initialSelectedOptions);
        this._cdkListbox.valueChange
            .asObservable()
            .pipe(takeUntilDestroyed())
            .subscribe((val) => this._selectService.listBoxValueChangeEvent$.next(val));
        effect(() => {
            this._cdkListbox.multiple = this._selectService.multiple();
            this._selectService.isExpanded() && setTimeout(() => this.updateArrowDisplay());
        });
    }
    ngAfterViewInit() {
        this.setInitiallySelectedOptions();
    }
    setInitiallySelectedOptions() {
        this.initialSelectedOptions$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((selectedOptions) => {
            // Reapplying cdkLibstbox multiple because seems this is running before effect that
            // updates cdklistbox, reapplying multiple true so we can set the multiple initial options
            if (this._selectService.multiple()) {
                this._cdkListbox.multiple = true;
            }
            this._selectService.possibleOptions().forEach((cdkOption) => {
                if (selectedOptions.includes(cdkOption)) {
                    cdkOption?.select();
                }
                else {
                    cdkOption?.deselect();
                }
            });
            selectedOptions.forEach((cdkOption) => cdkOption?.select());
        });
    }
    updateArrowDisplay() {
        this.canScrollUp.set(this.viewport.nativeElement.scrollTop > 0);
        const maxScroll = this.viewport.nativeElement.scrollHeight - this.viewport.nativeElement.clientHeight;
        this.canScrollDown.set(Math.ceil(this.viewport.nativeElement.scrollTop) < maxScroll);
    }
    handleScroll() {
        this.updateArrowDisplay();
    }
    focusList() {
        this._cdkListbox.focus();
    }
    moveFocusUp() {
        this.viewport.nativeElement.scrollBy({ top: -100, behavior: 'smooth' });
        if (this.viewport.nativeElement.scrollTop === 0) {
            this.scrollUpBtn.stopEmittingEvents();
        }
    }
    moveFocusDown() {
        this.viewport.nativeElement.scrollBy({ top: 100, behavior: 'smooth' });
        const viewportSize = this._el.nativeElement.scrollHeight;
        const viewportScrollPosition = this.viewport.nativeElement.scrollTop;
        if (viewportSize + viewportScrollPosition + 100 > this.viewport.nativeElement.scrollHeight + 50) {
            this.scrollDownBtn.stopEmittingEvents();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectContentComponent, isStandalone: true, selector: "brn-select-content, hlm-select-content:not(noHlm)", host: { properties: { "attr.aria-labelledBy": "labelledBy()", "attr.aria-controlledBy": "id() +'--trigger'", "id": "id() + '--content'", "attr.dir": "_selectService.dir()" } }, queries: [{ propertyName: "scrollUpBtn", first: true, predicate: BrnSelectScrollUpDirective, descendants: true }, { propertyName: "scrollDownBtn", first: true, predicate: BrnSelectScrollDownDirective, descendants: true }, { propertyName: "_options", predicate: BrnSelectOptionDirective, descendants: true }], viewQueries: [{ propertyName: "viewport", first: true, predicate: ["viewport"], descendants: true }], hostDirectives: [{ directive: i1.CdkListbox }], ngImport: i0, template: `
		<ng-template #scrollUp>
			<ng-content select="hlm-select-scroll-up" />
			<ng-content select="brnSelectScrollUp" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollUp() && scrollUpBtn ? scrollUp : null" />
		<div
			data-brn-select-viewport
			#viewport
			(scroll)="handleScroll()"
			style="flex: 1 1 0%;
			position: relative;
			width:100%;
			overflow:auto;
			min-height: 36px;
      padding-bottom: 2px;
      margin-bottom: -2px;"
		>
			<ng-content />
		</div>
		<ng-template #scrollDown>
			<ng-content select="brnSelectScrollDown" />
			<ng-content select="hlm-select-scroll-down" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollDown() && scrollDownBtn ? scrollDown : null" />
	`, isInline: true, styles: [":host{display:flex;box-sizing:border-box;flex-direction:column;outline:none;pointer-events:auto}[data-brn-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch}[data-brn-select-viewport]::-webkit-scrollbar{display:none}\n"], dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'brn-select-content, hlm-select-content:not(noHlm)', standalone: true, imports: [BrnSelectScrollUpDirective, BrnSelectScrollDownDirective, NgTemplateOutlet], hostDirectives: [CdkListbox], changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[attr.aria-labelledBy]': 'labelledBy()',
                        '[attr.aria-controlledBy]': "id() +'--trigger'",
                        '[id]': "id() + '--content'",
                        '[attr.dir]': '_selectService.dir()',
                    }, template: `
		<ng-template #scrollUp>
			<ng-content select="hlm-select-scroll-up" />
			<ng-content select="brnSelectScrollUp" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollUp() && scrollUpBtn ? scrollUp : null" />
		<div
			data-brn-select-viewport
			#viewport
			(scroll)="handleScroll()"
			style="flex: 1 1 0%;
			position: relative;
			width:100%;
			overflow:auto;
			min-height: 36px;
      padding-bottom: 2px;
      margin-bottom: -2px;"
		>
			<ng-content />
		</div>
		<ng-template #scrollDown>
			<ng-content select="brnSelectScrollDown" />
			<ng-content select="hlm-select-scroll-down" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollDown() && scrollDownBtn ? scrollDown : null" />
	`, styles: [":host{display:flex;box-sizing:border-box;flex-direction:column;outline:none;pointer-events:auto}[data-brn-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch}[data-brn-select-viewport]::-webkit-scrollbar{display:none}\n"] }]
        }], ctorParameters: () => [], propDecorators: { viewport: [{
                type: ViewChild,
                args: ['viewport']
            }], scrollUpBtn: [{
                type: ContentChild,
                args: [BrnSelectScrollUpDirective, { static: false }]
            }], scrollDownBtn: [{
                type: ContentChild,
                args: [BrnSelectScrollDownDirective, { static: false }]
            }], _options: [{
                type: ContentChildren,
                args: [BrnSelectOptionDirective, { descendants: true }]
            }] } });

class BrnSelectGroupDirective {
    constructor() {
        this.labelledBy = signal('');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectGroupDirective, isStandalone: true, selector: "[brnSelectGroup]", host: { attributes: { "role": "group" }, properties: { "attr.aria-labelledby": "labelledBy()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectGroup]',
                    standalone: true,
                    host: {
                        role: 'group',
                        '[attr.aria-labelledby]': 'labelledBy()',
                    },
                }]
        }] });

class BrnSelectLabelDirective {
    constructor() {
        this.group = inject(BrnSelectGroupDirective, { optional: true });
        this.label = inject(BrnLabelDirective, { host: true });
        this.group?.labelledBy.set(this.label.id);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectLabelDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectLabelDirective, isStandalone: true, selector: "[brnSelectLabel]", hostDirectives: [{ directive: i1$1.BrnLabelDirective }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectLabel]',
                    hostDirectives: [BrnLabelDirective],
                    standalone: true,
                }]
        }], ctorParameters: () => [] });

class BrnSelectTriggerDirective {
    constructor() {
        this.el = inject(ElementRef);
        this._selectService = inject(BrnSelectService);
        this._ngControl = inject(NgControl, { optional: true });
        this.isExpanded = this._selectService.isExpanded;
        this.selectTriggerId = computed(() => `${this._selectService.id()}--trigger`);
        this.selectContentId = computed(() => `${this._selectService.id()}--content`);
        this.selectDisable = computed(() => this._selectService.disabled());
        this.selectTriggerLabelledBy = computed(() => {
            if (this._selectService.value() && this._selectService.value().length > 0) {
                return `${this._selectService.labelId()} ${this._selectService.id()}--value`;
            }
            return this._selectService.labelId();
        });
        if (!this._selectService)
            return;
        this._selectService._setSelectTrigger(this);
    }
    ngAfterViewInit() {
        this._selectService.setTriggerWidth(this.el.nativeElement.offsetWidth);
    }
    focus() {
        this.el.nativeElement.focus();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectTriggerDirective, isStandalone: true, selector: "[brnSelectTrigger]", host: { attributes: { "role": "combobox", "aria-autocomplete": "none", "type": "button" }, properties: { "attr.id": "selectTriggerId()", "disabled": "selectDisable()", "attr.aria-expanded": "isExpanded()", "attr.aria-controls": "selectContentId() + ''", "attr.aria-labelledBy": "selectTriggerLabelledBy()", "attr.dir": "_selectService.dir()", "class.ng-invalid": "this._ngControl?.invalid || null", "class.ng-dirty": "this._ngControl?.dirty || null", "class.ng-valid": "this._ngControl?.valid || null", "class.ng-touched": "this._ngControl?.touched || null", "class.ng-untouched": "this._ngControl?.untouched || null", "class.ng-pristine": "this._ngControl?.pristine || null" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectTrigger]',
                    standalone: true,
                    host: {
                        role: 'combobox',
                        '[attr.id]': 'selectTriggerId()',
                        '[disabled]': 'selectDisable()',
                        '[attr.aria-expanded]': 'isExpanded()',
                        '[attr.aria-controls]': "selectContentId() + ''",
                        '[attr.aria-labelledBy]': 'selectTriggerLabelledBy()',
                        'aria-autocomplete': 'none',
                        '[attr.dir]': '_selectService.dir()',
                        '[class.ng-invalid]': 'this._ngControl?.invalid || null',
                        '[class.ng-dirty]': 'this._ngControl?.dirty || null',
                        '[class.ng-valid]': 'this._ngControl?.valid || null',
                        '[class.ng-touched]': 'this._ngControl?.touched || null',
                        '[class.ng-untouched]': 'this._ngControl?.untouched || null',
                        '[class.ng-pristine]': 'this._ngControl?.pristine || null',
                        type: 'button',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnSelectValueComponent {
    constructor() {
        this._selectService = inject(BrnSelectService);
        this.id = computed(() => `${this._selectService.id()}--value`);
        this.placeholder = computed(() => this._selectService.placeholder());
        this.value = computed(() => {
            const value = this._selectService.selectedOptions();
            if (value.length === 0) {
                return null;
            }
            const selectedLabels = value.map((selectedOption) => selectedOption?.getLabel());
            if (this._selectService.dir() === 'rtl') {
                selectedLabels.reverse();
            }
            return this.transformFn(selectedLabels);
        });
        this.transformFn = (values) => (values ?? []).join(', ');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectValueComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.5", type: BrnSelectValueComponent, isStandalone: true, selector: "brn-select-value, hlm-select-value", inputs: { transformFn: "transformFn" }, host: { properties: { "id": "id()" } }, ngImport: i0, template: `
		{{ value() || placeholder() }}
	`, isInline: true, styles: [":host{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;white-space:nowrap;pointer-events:none}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectValueComponent, decorators: [{
            type: Component,
            args: [{ selector: 'brn-select-value, hlm-select-value', template: `
		{{ value() || placeholder() }}
	`, host: {
                        '[id]': 'id()',
                    }, standalone: true, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;white-space:nowrap;pointer-events:none}\n"] }]
        }], propDecorators: { 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        transformFn: [{
                type: Input
            }] } });

let nextId = 0;
class BrnSelectComponent {
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set multiple(multiple) {
        this._selectService.state.update((state) => ({ ...state, multiple }));
    }
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set placeholder(placeholder) {
        this._selectService.state.update((state) => ({ ...state, placeholder }));
    }
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set disabled(disabled) {
        this._selectService.state.update((state) => ({ ...state, disabled }));
    }
    constructor() {
        this._selectService = inject(BrnSelectService);
        this.triggerWidth = this._selectService.triggerWidth;
        this._multiple = this._selectService.multiple;
        this._placeholder = this._selectService.placeholder;
        this._disabled = this._selectService.disabled;
        this.dir = input('ltr');
        this.openedChange = new EventEmitter();
        this.closeDelay = input(100);
        this.isExpanded = this._selectService.isExpanded;
        this._delayedExpanded = toSignal(toObservable(this.isExpanded).pipe(switchMap((expanded) => (!expanded ? of(expanded).pipe(delay(this.closeDelay())) : of(expanded))), takeUntilDestroyed()), { initialValue: false });
        this.state = computed(() => (this.isExpanded() ? 'open' : 'closed'));
        this._positionChanges$ = new Subject();
        this.side = toSignal(this._positionChanges$.pipe(map((change) => 
        // todo: better translation or adjusting hlm to take that into account
        change.connectionPair.originY === 'center'
            ? change.connectionPair.originX === 'start'
                ? 'left'
                : 'right'
            : change.connectionPair.originY)), { initialValue: 'bottom' });
        this.backupLabelId = computed(() => this._selectService.labelId());
        this.labelProvided = signal(false);
        this.ngControl = inject(NgControl, { optional: true, self: true });
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onChange = () => { };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onTouched = () => { };
        /*
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */
        this._positions = [
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top',
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top',
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom',
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom',
            },
        ];
        this._selectService.state.update((state) => ({
            ...state,
            id: `brn-select-${nextId++}`,
        }));
        if (this.ngControl != null) {
            this.ngControl.valueAccessor = this;
        }
        // Watch for Listbox Selection Changes to trigger Collapse
        this._selectService.listBoxValueChangeEvent$.pipe(takeUntilDestroyed()).subscribe(() => {
            if (!this._multiple()) {
                this.close();
            }
        });
        toObservable(this._selectService.value)
            // skipping first else ngcontrol always starts off as dirty and triggering value change on init value
            .pipe(takeUntilDestroyed(), skip(1))
            .subscribe((value) => this._onChange(value || null));
        toObservable(this.dir)
            .pipe(takeUntilDestroyed())
            .subscribe(() => this._selectService.state.update((state) => ({
            ...state,
            dir: this.dir(),
        })));
    }
    ngAfterContentInit() {
        // Check if Label Directive Provided and pass to service
        if (this.selectLabel) {
            this.labelProvided.set(true);
            this._selectService.state.update((state) => ({
                ...state,
                labelId: this.selectLabel.id,
                dir: this.dir(),
            }));
        }
        else if (this._placeholder()) {
            this._selectService.state.update((state) => ({
                ...state,
                labelId: `${state.id}--label`,
                dir: this.dir(),
            }));
        }
    }
    toggle() {
        if (this.isExpanded()) {
            this.close();
        }
        else {
            this.open();
        }
    }
    open() {
        if (!this._canOpen())
            return;
        this._selectService.state.update((state) => ({
            ...state,
            isExpanded: true,
        }));
        this.openedChange.next(true);
        this._moveFocusToCDKList();
    }
    close() {
        if (!this.isExpanded())
            return;
        if (this._selectService.selectTrigger) {
            this._selectService.selectTrigger.focus();
        }
        this.openedChange.next(false);
        this._selectService.state.update((state) => ({
            ...state,
            isExpanded: false,
        }));
        this._onTouched();
    }
    _canOpen() {
        return !this.isExpanded() && !this._disabled() && this.options?.length > 0;
    }
    _moveFocusToCDKList() {
        setTimeout(() => this.selectContent.focusList());
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    writeValue(value) {
        this._selectService.setInitialSelectedOptions(value);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.5", type: BrnSelectComponent, isStandalone: true, selector: "brn-select, hlm-select", inputs: { multiple: { classPropertyName: "multiple", publicName: "multiple", isSignal: false, isRequired: false, transformFunction: null }, placeholder: { classPropertyName: "placeholder", publicName: "placeholder", isSignal: false, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: false, isRequired: false, transformFunction: null }, dir: { classPropertyName: "dir", publicName: "dir", isSignal: true, isRequired: false, transformFunction: null }, closeDelay: { classPropertyName: "closeDelay", publicName: "closeDelay", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { openedChange: "openedChange" }, providers: [
            BrnSelectService,
            CdkListbox,
            provideExposedSideProviderExisting(() => BrnSelectComponent),
            provideExposesStateProviderExisting(() => BrnSelectComponent),
        ], queries: [{ propertyName: "selectLabel", first: true, predicate: BrnLabelDirective }, { propertyName: "selectContent", first: true, predicate: BrnSelectContentComponent, descendants: true }, { propertyName: "options", predicate: BrnSelectOptionDirective, descendants: true }], viewQueries: [{ propertyName: "_overlayDir", first: true, predicate: CdkConnectedOverlay, descendants: true }], ngImport: i0, template: `
		@if (!labelProvided() && _placeholder()) {
			<label class="hidden" [attr.id]="backupLabelId()">{{ _placeholder() }}</label>
		} @else {
			<ng-content select="label[hlmLabel],label[brnLabel]" />
		}

		<div cdk-overlay-origin (click)="toggle()" #trigger="cdkOverlayOrigin">
			<ng-content select="hlm-select-trigger,[brnSelectTrigger]" />
		</div>
		<ng-template
			cdk-connected-overlay
			cdkConnectedOverlayLockPosition
			cdkConnectedOverlayHasBackdrop
			cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
			[cdkConnectedOverlayOrigin]="trigger"
			[cdkConnectedOverlayOpen]="_delayedExpanded()"
			[cdkConnectedOverlayPositions]="_positions"
			[cdkConnectedOverlayWidth]="triggerWidth() > 0 ? triggerWidth() : 'auto'"
			(backdropClick)="close()"
			(detach)="close()"
			(positionChange)="_positionChanges$.next($event)"
		>
			<ng-content />
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "ngmodule", type: OverlayModule }, { kind: "directive", type: i1$2.CdkConnectedOverlay, selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", inputs: ["cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPositionStrategy", "cdkConnectedOverlayOffsetX", "cdkConnectedOverlayOffsetY", "cdkConnectedOverlayWidth", "cdkConnectedOverlayHeight", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayMinHeight", "cdkConnectedOverlayBackdropClass", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayViewportMargin", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOpen", "cdkConnectedOverlayDisableClose", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayLockPosition", "cdkConnectedOverlayFlexibleDimensions", "cdkConnectedOverlayGrowAfterOpen", "cdkConnectedOverlayPush", "cdkConnectedOverlayDisposeOnNavigation"], outputs: ["backdropClick", "positionChange", "attach", "detach", "overlayKeydown", "overlayOutsideClick"], exportAs: ["cdkConnectedOverlay"] }, { kind: "directive", type: i1$2.CdkOverlayOrigin, selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]", exportAs: ["cdkOverlayOrigin"] }, { kind: "ngmodule", type: CdkListboxModule }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-select, hlm-select',
                    standalone: true,
                    imports: [OverlayModule, BrnSelectTriggerDirective, CdkListboxModule, JsonPipe],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        BrnSelectService,
                        CdkListbox,
                        provideExposedSideProviderExisting(() => BrnSelectComponent),
                        provideExposesStateProviderExisting(() => BrnSelectComponent),
                    ],
                    template: `
		@if (!labelProvided() && _placeholder()) {
			<label class="hidden" [attr.id]="backupLabelId()">{{ _placeholder() }}</label>
		} @else {
			<ng-content select="label[hlmLabel],label[brnLabel]" />
		}

		<div cdk-overlay-origin (click)="toggle()" #trigger="cdkOverlayOrigin">
			<ng-content select="hlm-select-trigger,[brnSelectTrigger]" />
		</div>
		<ng-template
			cdk-connected-overlay
			cdkConnectedOverlayLockPosition
			cdkConnectedOverlayHasBackdrop
			cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
			[cdkConnectedOverlayOrigin]="trigger"
			[cdkConnectedOverlayOpen]="_delayedExpanded()"
			[cdkConnectedOverlayPositions]="_positions"
			[cdkConnectedOverlayWidth]="triggerWidth() > 0 ? triggerWidth() : 'auto'"
			(backdropClick)="close()"
			(detach)="close()"
			(positionChange)="_positionChanges$.next($event)"
		>
			<ng-content />
		</ng-template>
	`,
                }]
        }], ctorParameters: () => [], propDecorators: { multiple: [{
                type: Input,
                args: [{ alias: 'multiple' }]
            }], placeholder: [{
                type: Input,
                args: [{ alias: 'placeholder' }]
            }], disabled: [{
                type: Input,
                args: [{ alias: 'disabled' }]
            }], selectLabel: [{
                type: ContentChild,
                args: [BrnLabelDirective, { descendants: false }]
            }], selectContent: [{
                type: ContentChild,
                args: [BrnSelectContentComponent]
            }], options: [{
                type: ContentChildren,
                args: [BrnSelectOptionDirective, { descendants: true }]
            }], _overlayDir: [{
                type: ViewChild,
                args: [CdkConnectedOverlay]
            }], openedChange: [{
                type: Output
            }] } });

const BrnSelectImports = [
    BrnSelectComponent,
    BrnSelectContentComponent,
    BrnSelectTriggerDirective,
    BrnSelectOptionDirective,
    BrnSelectValueComponent,
    BrnSelectScrollDownDirective,
    BrnSelectScrollUpDirective,
    BrnSelectGroupDirective,
    BrnSelectLabelDirective,
];
class BrnSelectModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectModule, imports: [BrnSelectComponent,
            BrnSelectContentComponent,
            BrnSelectTriggerDirective,
            BrnSelectOptionDirective,
            BrnSelectValueComponent,
            BrnSelectScrollDownDirective,
            BrnSelectScrollUpDirective,
            BrnSelectGroupDirective,
            BrnSelectLabelDirective], exports: [BrnSelectComponent,
            BrnSelectContentComponent,
            BrnSelectTriggerDirective,
            BrnSelectOptionDirective,
            BrnSelectValueComponent,
            BrnSelectScrollDownDirective,
            BrnSelectScrollUpDirective,
            BrnSelectGroupDirective,
            BrnSelectLabelDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectModule, imports: [BrnSelectComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSelectModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnSelectImports],
                    exports: [...BrnSelectImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnSelectComponent, BrnSelectContentComponent, BrnSelectGroupDirective, BrnSelectImports, BrnSelectLabelDirective, BrnSelectModule, BrnSelectOptionDirective, BrnSelectScrollDownDirective, BrnSelectScrollUpDirective, BrnSelectService, BrnSelectTriggerDirective, BrnSelectValueComponent };
//# sourceMappingURL=spartan-ng-ui-select-brain.mjs.map
