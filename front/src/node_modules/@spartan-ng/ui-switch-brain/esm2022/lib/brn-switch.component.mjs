import { FocusMonitor } from '@angular/cdk/a11y';
import { NgStyle, isPlatformBrowser } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Input, Output, PLATFORM_ID, Renderer2, ViewChild, ViewEncapsulation, booleanAttribute, effect, forwardRef, inject, signal, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { rxHostPressedListener } from '@spartan-ng/ui-core';
import * as i0 from "@angular/core";
export const BRN_SWITCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnSwitchComponent),
    multi: true,
};
const CONTAINER_POST_FIX = '-switch';
export class BrnSwitchComponent {
    set checked(value) {
        this._checked.set(value);
    }
    set id(value) {
        if (!value)
            return;
        this._id.set(value + CONTAINER_POST_FIX);
    }
    set name(value) {
        if (!value)
            return;
        this._name.set(value + CONTAINER_POST_FIX);
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
    }
    set disabled(value) {
        this._disabled.set(value);
    }
    constructor() {
        this._renderer = inject(Renderer2);
        this._isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this._elementRef = inject(ElementRef);
        this._focusMonitor = inject(FocusMonitor);
        this._cdr = inject(ChangeDetectorRef);
        this.focusVisible = signal(false);
        this.focused = signal(false);
        this._checked = signal(false);
        /** Used to set the id on the underlying input element. */
        this._id = signal(null);
        /** Used to set the name attribute on the underlying input element. */
        this._name = signal(null);
        /** Used to set the aria-label attribute on the underlying input element. */
        this.ariaLabel = null;
        /** Used to set the aria-labelledby attribute on the underlying input element. */
        this.ariaLabelledby = null;
        /** Used to set the aria-describedby attribute on the underlying input element. */
        this._ariaDescribedby = null;
        this.ariaDescribedby = null;
        this._required = false;
        this._disabled = signal(false);
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,,@typescript-eslint/no-explicit-any
        this._onChange = (_) => { };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onTouched = () => { };
        this.changed = new EventEmitter();
        this.touched = new EventEmitter();
        rxHostPressedListener().subscribe(() => this.handleChange());
        effect(() => {
            /** search for the label and set the disabled state */
            let parent = this._renderer.parentNode(this._elementRef.nativeElement);
            if (!parent)
                return;
            // if parent is a HLM-SWITCH, then we need to go up one more level to get the label
            if (parent?.tagName === 'HLM-SWITCH') {
                parent = this._renderer.parentNode(parent);
            }
            if (!parent)
                return;
            // check if parent is a label and assume it is for this checkbox
            if (parent?.tagName === 'LABEL') {
                this._renderer.setAttribute(parent, 'data-disabled', this._disabled() ? 'true' : 'false');
                return;
            }
            if (!this._isBrowser)
                return;
            const label = parent?.querySelector(`label[for="${this.forChild(this._id())}"]`);
            if (!label)
                return;
            this._renderer.setAttribute(label, 'data-disabled', this._disabled() ? 'true' : 'false');
        });
    }
    handleChange() {
        if (this._disabled())
            return;
        const previousChecked = this._checked();
        if (!this.checkbox)
            return;
        this._checked.set(!previousChecked);
        this._onChange(!previousChecked);
        this.changed.emit(!previousChecked);
    }
    ngAfterContentInit() {
        this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
            if (focusOrigin)
                this.focused.set(true);
            if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
                this.focusVisible.set(true);
                this._cdr.markForCheck();
            }
            if (!focusOrigin) {
                // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                // Angular does not expect events to be raised during change detection, so any state
                // change (such as a form control's ng-touched) will cause a changed-after-checked error.
                // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                // telling the form control it has been touched until the next tick.
                Promise.resolve().then(() => {
                    this.focusVisible.set(false);
                    this.focused.set(false);
                    this._onTouched();
                    this.touched.emit();
                    this._cdr.markForCheck();
                });
            }
        });
        if (!this.checkbox)
            return;
        this.checkbox.nativeElement.value = this._checked() ? 'on' : 'off';
        this.checkbox.nativeElement.dispatchEvent(new Event('change'));
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    forChild(parentValue) {
        return parentValue ? parentValue.replace(CONTAINER_POST_FIX, '') : null;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    writeValue(value) {
        this.checked = !!value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /** Implemented as a part of ControlValueAccessor. */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cdr.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.5", type: BrnSwitchComponent, isStandalone: true, selector: "brn-switch", inputs: { checked: ["checked", "checked", booleanAttribute], id: "id", name: "name", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], required: ["required", "required", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { changed: "changed", touched: "touched" }, host: { attributes: { "tabindex": "0" }, properties: { "attr.data-state": "_checked() ? \"checked\" : \"unchecked\"", "attr.data-focus-visible": "focusVisible()", "attr.data-focus": "focused()", "attr.data-disabled": "_disabled()", "attr.aria-labelledby": "null", "attr.aria-label": "null", "attr.aria-describedby": "this._ariaDescribedby", "attr.id": "_id()", "attr.name": "_name()" } }, providers: [BRN_SWITCH_VALUE_ACCESSOR], viewQueries: [{ propertyName: "checkbox", first: true, predicate: ["checkBox"], descendants: true, static: true }], ngImport: i0, template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="switch"
			[id]="forChild(_id()) ?? ''"
			[name]="forChild(_name()) ?? ''"
			[value]="_checked() ? 'on' : 'off'"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: -'1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0'
			}"
			[checked]="_checked()"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-describedby]="ariaDescribedby"
			[attr.aria-required]="required || null"
		/>
		<ng-content select="brn-switch-thumb" />
	`, isInline: true, dependencies: [{ kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-switch',
                    standalone: true,
                    imports: [NgStyle],
                    template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="switch"
			[id]="forChild(_id()) ?? ''"
			[name]="forChild(_name()) ?? ''"
			[value]="_checked() ? 'on' : 'off'"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: -'1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0'
			}"
			[checked]="_checked()"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-describedby]="ariaDescribedby"
			[attr.aria-required]="required || null"
		/>
		<ng-content select="brn-switch-thumb" />
	`,
                    host: {
                        tabindex: '0',
                        '[attr.data-state]': '_checked() ? "checked" : "unchecked"',
                        '[attr.data-focus-visible]': 'focusVisible()',
                        '[attr.data-focus]': 'focused()',
                        '[attr.data-disabled]': '_disabled()',
                        '[attr.aria-labelledby]': 'null',
                        '[attr.aria-label]': 'null',
                        '[attr.aria-describedby]': 'null',
                        '[attr.id]': '_id()',
                        '[attr.name]': '_name()',
                    },
                    providers: [BRN_SWITCH_VALUE_ACCESSOR],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: () => [], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], id: [{
                type: Input
            }], name: [{
                type: Input
            }], ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }], ariaLabelledby: [{
                type: Input,
                args: ['aria-labelledby']
            }], _ariaDescribedby: [{
                type: HostBinding,
                args: ['attr.aria-describedby']
            }], ariaDescribedby: [{
                type: Input,
                args: ['aria-describedby']
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], checkbox: [{
                type: ViewChild,
                args: ['checkBox', { static: true }]
            }], changed: [{
                type: Output
            }], touched: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJuLXN3aXRjaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL3VpL3N3aXRjaC9icmFpbi9zcmMvbGliL2Jybi1zd2l0Y2guY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDN0QsT0FBTyxFQUNOLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxNQUFNLEVBQ04sV0FBVyxFQUNYLFNBQVMsRUFDVCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQixNQUFNLEVBQ04sVUFBVSxFQUNWLE1BQU0sRUFDTixNQUFNLEdBR04sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0scUJBQXFCLENBQUM7O0FBRTVELE1BQU0sQ0FBQyxNQUFNLHlCQUF5QixHQUFHO0lBQ3hDLE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztJQUNqRCxLQUFLLEVBQUUsSUFBSTtDQUNYLENBQUM7QUFFRixNQUFNLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztBQWtEckMsTUFBTSxPQUFPLGtCQUFrQjtJQVc5QixJQUNJLE9BQU8sQ0FBQyxLQUFjO1FBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFLRCxJQUNJLEVBQUUsQ0FBQyxLQUFvQjtRQUMxQixJQUFJLENBQUMs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LG1CQUFtQixFQUFFLHNDQUFzQzt3QkFDM0QsMkJBQTJCLEVBQUUsZ0JBQWdCO3dCQUM3QyxtQkFBbUIsRUFBRSxXQUFXO3dCQUNoQyxzQkFBc0IsRUFBRSxhQUFhO3dCQUNyQyx3QkFBd0IsRUFBRSxNQUFNO3dCQUNoQyxtQkFBbUIsRUFBRSxNQUFNO3dCQUMzQix5QkFBeUIsRUFBRSxNQUFNO3dCQUNqQyxXQUFXLEVBQUUsT0FBTzt3QkFDcEIsYUFBYSxFQUFFLFNBQVM7cUJBQ3hCO29CQUNELFNBQVMsRUFBRSxDQUFDLHlCQUF5QixDQUFDO29CQUN0QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7aUJBQ3JDO3dEQWFJLE9BQU87c0JBRFYsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtnQkFTbEMsRUFBRTtzQkFETCxLQUFLO2dCQVNGLElBQUk7c0JBRFAsS0FBSztnQkFRTixTQUFTO3NCQURSLEtBQUs7dUJBQUMsWUFBWTtnQkFLbkIsY0FBYztzQkFEYixLQUFLO3VCQUFDLGlCQUFpQjtnQkFLaEIsZ0JBQWdCO3NCQUR2QixXQUFXO3VCQUFDLHVCQUF1QjtnQkFJcEMsZUFBZTtzQkFEZCxLQUFLO3VCQUFDLGtCQUFrQjtnQkFLckIsUUFBUTtzQkFEWCxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFO2dCQVdsQyxRQUFRO3NCQURYLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBVy9CLFFBQVE7c0JBRGQsU0FBUzt1QkFBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUloQyxPQUFPO3NCQURiLE1BQU07Z0JBR0EsT0FBTztzQkFEYixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgTmdTdHlsZSwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcblx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG5cdENoYW5nZURldGVjdG9yUmVmLFxuXHRDb21wb25lbnQsXG5cdEVsZW1lbnRSZWYsXG5cdEV2ZW50RW1pdHRlcixcblx0SG9zdEJpbmRpbmcsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdFBMQVRGT1JNX0lELFxuXHRSZW5kZXJlcjIsXG5cdFZpZXdDaGlsZCxcblx0Vmlld0VuY2Fwc3VsYXRpb24sXG5cdGJvb2xlYW5BdHRyaWJ1dGUsXG5cdGVmZmVjdCxcblx0Zm9yd2FyZFJlZixcblx0aW5qZWN0LFxuXHRzaWduYWwsXG5cdHR5cGUgQWZ0ZXJDb250ZW50SW5pdCxcblx0dHlwZSBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyByeEhvc3RQcmVzc2VkTGlzdGVuZXIgfSBmcm9tICdAc3BhcnRhbi1uZy91aS1jb3JlJztcblxuZXhwb3J0IGNvbnN0IEJSTl9TV0lUQ0hfVkFMVUVfQUNDRVNTT1IgPSB7XG5cdHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuXHR1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBCcm5Td2l0Y2hDb21wb25lbnQpLFxuXHRtdWx0aTogdHJ1ZSxcbn07XG5cbmNvbnN0IENPTlRBSU5FUl9QT1NUX0ZJWCA9ICctc3dpdGNoJztcblxuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiAnYnJuLXN3aXRjaCcsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdGltcG9ydHM6IFtOZ1N0eWxlXSxcblx0dGVtcGxhdGU6IGBcblx0XHQ8aW5wdXRcblx0XHRcdCNjaGVja0JveFxuXHRcdFx0dGFiaW5kZXg9XCItMVwiXG5cdFx0XHR0eXBlPVwiY2hlY2tib3hcIlxuXHRcdFx0cm9sZT1cInN3aXRjaFwiXG5cdFx0XHRbaWRdPVwiZm9yQ2hpbGQoX2lkKCkpID8/ICcnXCJcblx0XHRcdFtuYW1lXT1cImZvckNoaWxkKF9uYW1lKCkpID8/ICcnXCJcblx0XHRcdFt2YWx1ZV09XCJfY2hlY2tlZCgpID8gJ29uJyA6ICdvZmYnXCJcblx0XHRcdFtuZ1N0eWxlXT1cIntcblx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdHdpZHRoOiAnMXB4Jyxcblx0XHRcdFx0aGVpZ2h0OiAnMXB4Jyxcblx0XHRcdFx0cGFkZGluZzogJzAnLFxuXHRcdFx0XHRtYXJnaW46IC0nMXB4Jyxcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRjbGlwOiAncmVjdCgwLCAwLCAwLCAwKScsXG5cdFx0XHRcdHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogJzAnXG5cdFx0XHR9XCJcblx0XHRcdFtjaGVja2VkXT1cIl9jaGVja2VkKClcIlxuXHRcdFx0W2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWxcIlxuXHRcdFx0W2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcblx0XHRcdFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiYXJpYURlc2NyaWJlZGJ5XCJcblx0XHRcdFthdHRyLmFyaWEtcmVxdWlyZWRdPVwicmVxdWlyZWQgfHwgbnVsbFwiXG5cdFx0Lz5cblx0XHQ8bmctY29udGVudCBzZWxlY3Q9XCJicm4tc3dpdGNoLXRodW1iXCIgLz5cblx0YCxcblx0aG9zdDoge1xuXHRcdHRhYmluZGV4OiAnMCcsXG5cdFx0J1thdHRyLmRhdGEtc3RhdGVdJzogJ19jaGVja2VkKCkgPyBcImNoZWNrZWRcIiA6IFwidW5jaGVja2VkXCInLFxuXHRcdCdbYXR0ci5kYXRhLWZvY3VzLXZpc2libGVdJzogJ2ZvY3VzVmlzaWJsZSgpJyxcblx0XHQnW2F0dHIuZGF0YS1mb2N1c10nOiAnZm9jdXNlZCgpJyxcblx0XHQnW2F0dHIuZGF0YS1kaXNhYmxlZF0nOiAnX2Rpc2FibGVkKCknLFxuXHRcdCdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ251bGwnLFxuXHRcdCdbYXR0ci5hcmlhLWxhYmVsXSc6ICdudWxsJyxcblx0XHQnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnbnVsbCcsXG5cdFx0J1thdHRyLmlkXSc6ICdfaWQoKScsXG5cdFx0J1thdHRyLm5hbWVdJzogJ19uYW1lKCknLFxuXHR9LFxuXHRwcm92aWRlcnM6IFtCUk5fU1dJVENIX1ZBTFVFX0FDQ0VTU09SXSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG5cdGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuZXhwb3J0IGNsYXNzIEJyblN3aXRjaENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cdHByaXZhdGUgcmVhZG9ubHkgX3JlbmRlcmVyID0gaW5qZWN0KFJlbmRlcmVyMik7XG5cdHByaXZhdGUgcmVhZG9ubHkgX2lzQnJvd3NlciA9IGlzUGxhdGZvcm1Ccm93c2VyKGluamVjdChQTEFURk9STV9JRCkpO1xuXHRwcml2YXRlIF9lbGVtZW50UmVmID0gaW5qZWN0KEVsZW1lbnRSZWYpO1xuXHRwcml2YXRlIF9mb2N1c01vbml0b3IgPSBpbmplY3QoRm9jdXNNb25pdG9yKTtcblx0cHJpdmF0ZSBfY2RyID0gaW5qZWN0KENoYW5nZURldGVjdG9yUmVmKTtcblxuXHRwdWJsaWMgZm9jdXNWaXNpYmxlID0gc2lnbmFsKGZhbHNlKTtcblx0cHVibGljIGZvY3VzZWQgPSBzaWduYWwoZmFsc2UpO1xuXG5cdHByb3RlY3RlZCBfY2hlY2tlZCA9IHNpZ25hbChmYWxzZSk7XG5cdEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuXHRzZXQgY2hlY2tlZCh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuX2NoZWNrZWQuc2V0KHZhbHVlKTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIHNldCB0aGUgaWQgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cblxuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgX2lkID0gc2lnbmFsPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXHRASW5wdXQoKVxuXHRzZXQgaWQodmFsdWU6IHN0cmluZyB8IG51bGwpIHtcblx0XHRpZiAoIXZhbHVlKSByZXR1cm47XG5cdFx0dGhpcy5faWQuc2V0KHZhbHVlICsgQ09OVEFJTkVSX1BPU1RfRklYKTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIHNldCB0aGUgbmFtZSBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cblx0cHJvdGVjdGVkIHJlYWRvbmx5IF9uYW1lID0gc2lnbmFsPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXHRASW5wdXQoKVxuXHRzZXQgbmFtZSh2YWx1ZTogc3RyaW5nIHwgbnVsbCkge1xuXHRcdGlmICghdmFsdWUpIHJldHVybjtcblx0XHR0aGlzLl9uYW1lLnNldCh2YWx1ZSArIENPTlRBSU5FUl9QT1NUX0ZJWCk7XG5cdH1cblxuXHQvKiogVXNlZCB0byBzZXQgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9uIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnQuICovXG5cdEBJbnB1dCgnYXJpYS1sYWJlbCcpXG5cdGFyaWFMYWJlbDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cblx0LyoqIFVzZWQgdG8gc2V0IHRoZSBhcmlhLWxhYmVsbGVkYnkgYXR0cmlidXRlIG9uIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnQuICovXG5cdEBJbnB1dCgnYXJpYS1sYWJlbGxlZGJ5Jylcblx0YXJpYUxhYmVsbGVkYnk6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG5cdC8qKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1kZXNjcmliZWRieSBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cblx0QEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZGVzY3JpYmVkYnknKVxuXHRwcml2YXRlIF9hcmlhRGVzY3JpYmVkYnk6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG5cdEBJbnB1dCgnYXJpYS1kZXNjcmliZWRieScpXG5cdGFyaWFEZXNjcmliZWRieTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cblx0cHJpdmF0ZSBfcmVxdWlyZWQgPSBmYWxzZTtcblx0QElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG5cdGdldCByZXF1aXJlZCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVxdWlyZWQ7XG5cdH1cblxuXHRzZXQgcmVxdWlyZWQodmFsdWU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9yZXF1aXJlZCA9IHZhbHVlO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlYWRvbmx5IF9kaXNhYmxlZCA9IHNpZ25hbChmYWxzZSk7XG5cdEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuXHRzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9kaXNhYmxlZC5zZXQodmFsdWUpO1xuXHR9XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMsLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblx0cHJvdGVjdGVkIF9vbkNoYW5nZSA9IChfOiBhbnkpID0+IHt9O1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5cdHByaXZhdGUgX29uVG91Y2hlZCA9ICgpID0+IHt9O1xuXG5cdEBWaWV3Q2hpbGQoJ2NoZWNrQm94JywgeyBzdGF0aWM6IHRydWUgfSlcblx0cHVibGljIGNoZWNrYm94PzogRWxlbWVudFJlZjxIVE1MSW5wdXRFbGVtZW50PjtcblxuXHRAT3V0cHV0KClcblx0cHVibGljIGNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cdEBPdXRwdXQoKVxuXHRwdWJsaWMgdG91Y2hlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRyeEhvc3RQcmVzc2VkTGlzdGVuZXIoKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oYW5kbGVDaGFuZ2UoKSk7XG5cdFx0ZWZmZWN0KCgpID0+IHtcblx0XHRcdC8qKiBzZWFyY2ggZm9yIHRoZSBsYWJlbCBhbmQgc2V0IHRoZSBkaXNhYmxlZCBzdGF0ZSAqL1xuXHRcdFx0bGV0IHBhcmVudCA9IHRoaXMuX3JlbmRlcmVyLnBhcmVudE5vZGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcblx0XHRcdGlmICghcGFyZW50KSByZXR1cm47XG5cdFx0XHQvLyBpZiBwYXJlbnQgaXMgYSBITE0tU1dJVENILCB0aGVuIHdlIG5lZWQgdG8gZ28gdXAgb25lIG1vcmUgbGV2ZWwgdG8gZ2V0IHRoZSBsYWJlbFxuXHRcdFx0aWYgKHBhcmVudD8udGFnTmFtZSA9PT0gJ0hMTS1TV0lUQ0gnKSB7XG5cdFx0XHRcdHBhcmVudCA9IHRoaXMuX3JlbmRlcmVyLnBhcmVudE5vZGUocGFyZW50KTtcblx0XHRcdH1cblx0XHRcdGlmICghcGFyZW50KSByZXR1cm47XG5cdFx0XHQvLyBjaGVjayBpZiBwYXJlbnQgaXMgYSBsYWJlbCBhbmQgYXNzdW1lIGl0IGlzIGZvciB0aGlzIGNoZWNrYm94XG5cdFx0XHRpZiAocGFyZW50Py50YWdOYW1lID09PSAnTEFCRUwnKSB7XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShwYXJlbnQsICdkYXRhLWRpc2FibGVkJywgdGhpcy5fZGlzYWJsZWQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuX2lzQnJvd3NlcikgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCBsYWJlbCA9IHBhcmVudD8ucXVlcnlTZWxlY3RvcihgbGFiZWxbZm9yPVwiJHt0aGlzLmZvckNoaWxkKHRoaXMuX2lkKCkpfVwiXWApO1xuXHRcdFx0aWYgKCFsYWJlbCkgcmV0dXJuO1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGxhYmVsLCAnZGF0YS1kaXNhYmxlZCcsIHRoaXMuX2Rpc2FibGVkKCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcblx0XHR9KTtcblx0fVxuXG5cdGhhbmRsZUNoYW5nZSgpIHtcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQoKSkgcmV0dXJuO1xuXHRcdGNvbnN0IHByZXZpb3VzQ2hlY2tlZCA9IHRoaXMuX2NoZWNrZWQoKTtcblx0XHRpZiAoIXRoaXMuY2hlY2tib3gpIHJldHVybjtcblx0XHR0aGlzLl9jaGVja2VkLnNldCghcHJldmlvdXNDaGVja2VkKTtcblx0XHR0aGlzLl9vbkNoYW5nZSghcHJldmlvdXNDaGVja2VkKTtcblx0XHR0aGlzLmNoYW5nZWQuZW1pdCghcHJldmlvdXNDaGVja2VkKTtcblx0fVxuXG5cdG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblx0XHR0aGlzLl9mb2N1c01vbml0b3IubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLCB0cnVlKS5zdWJzY3JpYmUoKGZvY3VzT3JpZ2luKSA9PiB7XG5cdFx0XHRpZiAoZm9jdXNPcmlnaW4pIHRoaXMuZm9jdXNlZC5zZXQodHJ1ZSk7XG5cdFx0XHRpZiAoZm9jdXNPcmlnaW4gPT09ICdrZXlib2FyZCcgfHwgZm9jdXNPcmlnaW4gPT09ICdwcm9ncmFtJykge1xuXHRcdFx0XHR0aGlzLmZvY3VzVmlzaWJsZS5zZXQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcblx0XHRcdH1cblx0XHRcdGlmICghZm9jdXNPcmlnaW4pIHtcblx0XHRcdFx0Ly8gV2hlbiBhIGZvY3VzZWQgZWxlbWVudCBiZWNvbWVzIGRpc2FibGVkLCB0aGUgYnJvd3NlciAqaW1tZWRpYXRlbHkqIGZpcmVzIGEgYmx1ciBldmVudC5cblx0XHRcdFx0Ly8gQW5ndWxhciBkb2VzIG5vdCBleHBlY3QgZXZlbnRzIHRvIGJlIHJhaXNlZCBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbiwgc28gYW55IHN0YXRlXG5cdFx0XHRcdC8vIGNoYW5nZSAoc3VjaCBhcyBhIGZvcm0gY29udHJvbCdzIG5nLXRvdWNoZWQpIHdpbGwgY2F1c2UgYSBjaGFuZ2VkLWFmdGVyLWNoZWNrZWQgZXJyb3IuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xNzc5My4gVG8gd29yayBhcm91bmQgdGhpcywgd2UgZGVmZXJcblx0XHRcdFx0Ly8gdGVsbGluZyB0aGUgZm9ybSBjb250cm9sIGl0IGhhcyBiZWVuIHRvdWNoZWQgdW50aWwgdGhlIG5leHQgdGljay5cblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1c1Zpc2libGUuc2V0KGZhbHNlKTtcblx0XHRcdFx0XHR0aGlzLmZvY3VzZWQuc2V0KGZhbHNlKTtcblx0XHRcdFx0XHR0aGlzLl9vblRvdWNoZWQoKTtcblx0XHRcdFx0XHR0aGlzLnRvdWNoZWQuZW1pdCgpO1xuXHRcdFx0XHRcdHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMuY2hlY2tib3gpIHJldHVybjtcblx0XHR0aGlzLmNoZWNrYm94Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLl9jaGVja2VkKCkgPyAnb24nIDogJ29mZic7XG5cdFx0dGhpcy5jaGVja2JveC5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSk7XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpIHtcblx0XHR0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5fZWxlbWVudFJlZik7XG5cdH1cblxuXHRmb3JDaGlsZChwYXJlbnRWYWx1ZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZyB8IG51bGwge1xuXHRcdHJldHVybiBwYXJlbnRWYWx1ZSA/IHBhcmVudFZhbHVlLnJlcGxhY2UoQ09OVEFJTkVSX1BPU1RfRklYLCAnJykgOiBudWxsO1xuXHR9XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblx0d3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG5cdFx0dGhpcy5jaGVja2VkID0gISF2YWx1ZTtcblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuXHRcdHRoaXMuX29uQ2hhbmdlID0gZm47XG5cdH1cblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG5cdFx0dGhpcy5fb25Ub3VjaGVkID0gZm47XG5cdH1cblxuXHQvKiogSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcblx0XHR0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0XHR0aGlzLl9jZHIubWFya0ZvckNoZWNrKCk7XG5cdH1cbn1cbiJdfQ==