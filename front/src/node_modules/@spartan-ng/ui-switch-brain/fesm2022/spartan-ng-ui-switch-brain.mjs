import * as i0 from '@angular/core';
import { Component, forwardRef, inject, Renderer2, PLATFORM_ID, ElementRef, ChangeDetectorRef, signal, EventEmitter, effect, booleanAttribute, ChangeDetectionStrategy, ViewEncapsulation, Input, HostBinding, ViewChild, Output, NgModule } from '@angular/core';
import { CommonModule, isPlatformBrowser, NgStyle } from '@angular/common';
import { FocusMonitor } from '@angular/cdk/a11y';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { rxHostPressedListener } from '@spartan-ng/ui-core';

class BrnSwitchThumbComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchThumbComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.5", type: BrnSwitchThumbComponent, isStandalone: true, selector: "brn-switch-thumb", ngImport: i0, template: ``, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchThumbComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-switch-thumb',
                    standalone: true,
                    imports: [CommonModule],
                    template: ``,
                }]
        }] });

const BRN_SWITCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnSwitchComponent),
    multi: true,
};
const CONTAINER_POST_FIX = '-switch';
class BrnSwitchComponent {
    set checked(value) {
        this._checked.set(value);
    }
    set id(value) {
        if (!value)
            return;
        this._id.set(value + CONTAINER_POST_FIX);
    }
    set name(value) {
        if (!value)
            return;
        this._name.set(value + CONTAINER_POST_FIX);
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
    }
    set disabled(value) {
        this._disabled.set(value);
    }
    constructor() {
        this._renderer = inject(Renderer2);
        this._isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this._elementRef = inject(ElementRef);
        this._focusMonitor = inject(FocusMonitor);
        this._cdr = inject(ChangeDetectorRef);
        this.focusVisible = signal(false);
        this.focused = signal(false);
        this._checked = signal(false);
        /** Used to set the id on the underlying input element. */
        this._id = signal(null);
        /** Used to set the name attribute on the underlying input element. */
        this._name = signal(null);
        /** Used to set the aria-label attribute on the underlying input element. */
        this.ariaLabel = null;
        /** Used to set the aria-labelledby attribute on the underlying input element. */
        this.ariaLabelledby = null;
        /** Used to set the aria-describedby attribute on the underlying input element. */
        this._ariaDescribedby = null;
        this.ariaDescribedby = null;
        this._required = false;
        this._disabled = signal(false);
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,,@typescript-eslint/no-explicit-any
        this._onChange = (_) => { };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onTouched = () => { };
        this.changed = new EventEmitter();
        this.touched = new EventEmitter();
        rxHostPressedListener().subscribe(() => this.handleChange());
        effect(() => {
            /** search for the label and set the disabled state */
            let parent = this._renderer.parentNode(this._elementRef.nativeElement);
            if (!parent)
                return;
            // if parent is a HLM-SWITCH, then we need to go up one more level to get the label
            if (parent?.tagName === 'HLM-SWITCH') {
                parent = this._renderer.parentNode(parent);
            }
            if (!parent)
                return;
            // check if parent is a label and assume it is for this checkbox
            if (parent?.tagName === 'LABEL') {
                this._renderer.setAttribute(parent, 'data-disabled', this._disabled() ? 'true' : 'false');
                return;
            }
            if (!this._isBrowser)
                return;
            const label = parent?.querySelector(`label[for="${this.forChild(this._id())}"]`);
            if (!label)
                return;
            this._renderer.setAttribute(label, 'data-disabled', this._disabled() ? 'true' : 'false');
        });
    }
    handleChange() {
        if (this._disabled())
            return;
        const previousChecked = this._checked();
        if (!this.checkbox)
            return;
        this._checked.set(!previousChecked);
        this._onChange(!previousChecked);
        this.changed.emit(!previousChecked);
    }
    ngAfterContentInit() {
        this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
            if (focusOrigin)
                this.focused.set(true);
            if (focusOrigin === 'keyboard' || focusOrigin === 'program') {
                this.focusVisible.set(true);
                this._cdr.markForCheck();
            }
            if (!focusOrigin) {
                // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                // Angular does not expect events to be raised during change detection, so any state
                // change (such as a form control's ng-touched) will cause a changed-after-checked error.
                // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                // telling the form control it has been touched until the next tick.
                Promise.resolve().then(() => {
                    this.focusVisible.set(false);
                    this.focused.set(false);
                    this._onTouched();
                    this.touched.emit();
                    this._cdr.markForCheck();
                });
            }
        });
        if (!this.checkbox)
            return;
        this.checkbox.nativeElement.value = this._checked() ? 'on' : 'off';
        this.checkbox.nativeElement.dispatchEvent(new Event('change'));
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    forChild(parentValue) {
        return parentValue ? parentValue.replace(CONTAINER_POST_FIX, '') : null;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    writeValue(value) {
        this.checked = !!value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /** Implemented as a part of ControlValueAccessor. */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cdr.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.5", type: BrnSwitchComponent, isStandalone: true, selector: "brn-switch", inputs: { checked: ["checked", "checked", booleanAttribute], id: "id", name: "name", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], required: ["required", "required", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { changed: "changed", touched: "touched" }, host: { attributes: { "tabindex": "0" }, properties: { "attr.data-state": "_checked() ? \"checked\" : \"unchecked\"", "attr.data-focus-visible": "focusVisible()", "attr.data-focus": "focused()", "attr.data-disabled": "_disabled()", "attr.aria-labelledby": "null", "attr.aria-label": "null", "attr.aria-describedby": "this._ariaDescribedby", "attr.id": "_id()", "attr.name": "_name()" } }, providers: [BRN_SWITCH_VALUE_ACCESSOR], viewQueries: [{ propertyName: "checkbox", first: true, predicate: ["checkBox"], descendants: true, static: true }], ngImport: i0, template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="switch"
			[id]="forChild(_id()) ?? ''"
			[name]="forChild(_name()) ?? ''"
			[value]="_checked() ? 'on' : 'off'"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: -'1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0'
			}"
			[checked]="_checked()"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-describedby]="ariaDescribedby"
			[attr.aria-required]="required || null"
		/>
		<ng-content select="brn-switch-thumb" />
	`, isInline: true, dependencies: [{ kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-switch',
                    standalone: true,
                    imports: [NgStyle],
                    template: `
		<input
			#checkBox
			tabindex="-1"
			type="checkbox"
			role="switch"
			[id]="forChild(_id()) ?? ''"
			[name]="forChild(_name()) ?? ''"
			[value]="_checked() ? 'on' : 'off'"
			[ngStyle]="{
				position: 'absolute',
				width: '1px',
				height: '1px',
				padding: '0',
				margin: -'1px',
				overflow: 'hidden',
				clip: 'rect(0, 0, 0, 0)',
				whiteSpace: 'nowrap',
				borderWidth: '0'
			}"
			[checked]="_checked()"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-describedby]="ariaDescribedby"
			[attr.aria-required]="required || null"
		/>
		<ng-content select="brn-switch-thumb" />
	`,
                    host: {
                        tabindex: '0',
                        '[attr.data-state]': '_checked() ? "checked" : "unchecked"',
                        '[attr.data-focus-visible]': 'focusVisible()',
                        '[attr.data-focus]': 'focused()',
                        '[attr.data-disabled]': '_disabled()',
                        '[attr.aria-labelledby]': 'null',
                        '[attr.aria-label]': 'null',
                        '[attr.aria-describedby]': 'null',
                        '[attr.id]': '_id()',
                        '[attr.name]': '_name()',
                    },
                    providers: [BRN_SWITCH_VALUE_ACCESSOR],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: () => [], propDecorators: { checked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], id: [{
                type: Input
            }], name: [{
                type: Input
            }], ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }], ariaLabelledby: [{
                type: Input,
                args: ['aria-labelledby']
            }], _ariaDescribedby: [{
                type: HostBinding,
                args: ['attr.aria-describedby']
            }], ariaDescribedby: [{
                type: Input,
                args: ['aria-describedby']
            }], required: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], checkbox: [{
                type: ViewChild,
                args: ['checkBox', { static: true }]
            }], changed: [{
                type: Output
            }], touched: [{
                type: Output
            }] } });

const BrnSwitchImports = [BrnSwitchComponent, BrnSwitchThumbComponent];
class BrnSwitchModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchModule, imports: [BrnSwitchComponent, BrnSwitchThumbComponent], exports: [BrnSwitchComponent, BrnSwitchThumbComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchModule, imports: [BrnSwitchThumbComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnSwitchModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnSwitchImports],
                    exports: [...BrnSwitchImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_SWITCH_VALUE_ACCESSOR, BrnSwitchComponent, BrnSwitchImports, BrnSwitchModule, BrnSwitchThumbComponent };
//# sourceMappingURL=spartan-ng-ui-switch-brain.mjs.map
