import * as i0 from '@angular/core';
import { input, EventEmitter, signal, Directive, Output, Input, inject, ElementRef, computed, effect, ContentChildren, NgModule } from '@angular/core';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { rxHostListener } from '@spartan-ng/ui-core';
import { take } from 'rxjs';

class BrnTabsDirective {
    constructor() {
        this.orientation = input('horizontal');
        /** internal **/
        this.$orientation = this.orientation;
        this.direction = input('ltr');
        /** internal **/
        this.$direction = this.direction;
        this.tabActivated = new EventEmitter();
        // leaving this as an @input and signal to be set programmatically
        // current limitation by InputSignal which are readonly
        this._value = signal(undefined);
        /** internal **/
        this.$value = this._value.asReadonly();
        this.activationMode = input('automatic');
        /** internal **/
        this.$activationMode = this.activationMode;
        this._tabs = {};
        this.$tabs = this._tabs;
    }
    set value(value) {
        this._value.set(value);
    }
    registerTrigger(key, trigger) {
        this._tabs[key] = {
            ...(this._tabs[key] ?? {}),
            trigger,
        };
    }
    registerContent(key, content) {
        this._tabs[key] = {
            ...(this._tabs[key] ?? {}),
            content,
        };
    }
    emitTabActivated(key) {
        this.tabActivated.emit(key);
    }
    setValue(key) {
        this._value.set(key);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "17.3.5", type: BrnTabsDirective, isStandalone: true, selector: "[brnTabs]", inputs: { orientation: { classPropertyName: "orientation", publicName: "orientation", isSignal: true, isRequired: false, transformFunction: null }, direction: { classPropertyName: "direction", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "brnTabs", isSignal: false, isRequired: false, transformFunction: null }, activationMode: { classPropertyName: "activationMode", publicName: "activationMode", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { tabActivated: "tabActivated" }, host: { properties: { "attr.data-orientation": "orientation()", "attr.dir": "direction()" } }, exportAs: ["brnTabs"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnTabs]',
                    standalone: true,
                    host: {
                        '[attr.data-orientation]': 'orientation()',
                        '[attr.dir]': 'direction()',
                    },
                    exportAs: 'brnTabs',
                }]
        }], propDecorators: { tabActivated: [{
                type: Output
            }], value: [{
                type: Input,
                args: ['brnTabs']
            }] } });

class BrnTabsContentDirective {
    constructor() {
        this._root = inject(BrnTabsDirective);
        this._elementRef = inject(ElementRef);
        this.contentFor = input.required({ alias: 'brnTabsContent' });
        this._isSelected = computed(() => this._root.$value() === this.contentFor());
        this.contentId = computed(() => 'brn-tabs-content-' + this.contentFor());
        this.labelId = computed(() => 'brn-tabs-label-' + this.contentFor());
        effect(() => {
            this._root.registerContent(this.contentFor(), this);
        });
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsContentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "17.3.5", type: BrnTabsContentDirective, isStandalone: true, selector: "[brnTabsContent]", inputs: { contentFor: { classPropertyName: "contentFor", publicName: "brnTabsContent", isSignal: true, isRequired: true, transformFunction: null } }, host: { attributes: { "role": "tabpanel", "tabindex": "0" }, properties: { "id": "contentId()", "attr.aria-labelledby": "labelId()", "hidden": "_isSelected() === false" } }, exportAs: ["brnTabsContent"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnTabsContent]',
                    standalone: true,
                    host: {
                        role: 'tabpanel',
                        tabindex: '0',
                        '[id]': 'contentId()',
                        '[attr.aria-labelledby]': 'labelId()',
                        '[hidden]': '_isSelected() === false',
                    },
                    exportAs: 'brnTabsContent',
                }]
        }], ctorParameters: () => [] });

class BrnTabsTriggerDirective {
    constructor() {
        this.elementRef = inject(ElementRef);
        this._root = inject(BrnTabsDirective);
        this._orientation = this._root.$orientation;
        this.triggerFor = input.required({ alias: 'brnTabsTrigger' });
        this.selected = computed(() => this._root.$value() === this.triggerFor());
        this.contentId = computed(() => 'brn-tabs-content-' + this.triggerFor());
        this.labelId = computed(() => 'brn-tabs-label-' + this.triggerFor());
        // leaving this as an @input to be compatible with the `FocusKeyManager` used in the `BrnTabsListDirective`
        this.disabled = false;
        effect(() => {
            this._root.registerTrigger(this.triggerFor(), this);
        });
    }
    focus() {
        this.elementRef.nativeElement.focus();
        if (this._root.$activationMode() === 'automatic') {
            this.activate();
        }
    }
    activate() {
        if (!this.triggerFor())
            return;
        this._root.setValue(this.triggerFor());
        this._root.emitTabActivated(this.triggerFor());
    }
    get key() {
        return this.triggerFor();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "17.3.5", type: BrnTabsTriggerDirective, isStandalone: true, selector: "button[brnTabsTrigger]", inputs: { triggerFor: { classPropertyName: "triggerFor", publicName: "brnTabsTrigger", isSignal: true, isRequired: true, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: false, isRequired: false, transformFunction: null } }, host: { attributes: { "type": "button", "role": "tab" }, listeners: { "click": "activate()" }, properties: { "id": "labelId()", "tabindex": "selected() ? \"0\": \"-1\"", "attr.aria-selected": "selected()", "attr.aria-controls": "contentId()", "attr.data-state": "selected() ? 'active' : 'inactive'", "attr.data-orientation": "_orientation()", "attr.data-disabled": "disabled ? '' : undefined" } }, exportAs: ["brnTabsTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button[brnTabsTrigger]',
                    standalone: true,
                    host: {
                        '[id]': 'labelId()',
                        type: 'button',
                        role: 'tab',
                        '[tabindex]': 'selected() ? "0": "-1"',
                        '[attr.aria-selected]': 'selected()',
                        '[attr.aria-controls]': 'contentId()',
                        '[attr.data-state]': "selected() ? 'active' : 'inactive'",
                        '[attr.data-orientation]': '_orientation()',
                        '[attr.data-disabled]': "disabled ? '' : undefined",
                        '(click)': 'activate()',
                    },
                    exportAs: 'brnTabsTrigger',
                }]
        }], ctorParameters: () => [], propDecorators: { disabled: [{
                type: Input
            }] } });

class BrnTabsListDirective {
    constructor() {
        this._root = inject(BrnTabsDirective);
        this._orientation = this._root.$orientation;
        this._direction = this._root.$direction;
        this._value = this._root.$value;
        this._tabs = this._root.$tabs;
        this._keyDownListener = rxHostListener('keydown');
    }
    ngAfterContentInit() {
        if (!this.triggers) {
            return;
        }
        this._keyManager = new FocusKeyManager(this.triggers)
            .withHorizontalOrientation(this._direction())
            .withHomeAndEnd()
            .withPageUpDown()
            .withWrap();
        // needed because by default the index is set to -1, which means first interaction is skipped
        this._keyDownListener.pipe(take(1)).subscribe(() => {
            const currentKey = this._value();
            let activeIndex = 0;
            if (currentKey && this.triggers) {
                const currentTab = this._tabs[currentKey];
                if (currentTab) {
                    activeIndex = this.triggers.toArray().indexOf(currentTab.trigger);
                }
            }
            this._keyManager?.setActiveItem(activeIndex);
        });
        this._keyDownListener.subscribe((event) => {
            if ('key' in event) {
                if (this._orientation() === 'horizontal') {
                    if (event.key === 'ArrowUp' || event.key === 'ArrowDown')
                        return;
                }
                if (this._orientation() === 'vertical') {
                    if (event.key === 'ArrowLeft' || event.key === 'ArrowRight')
                        return;
                }
            }
            this._keyManager?.onKeydown(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsListDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.5", type: BrnTabsListDirective, isStandalone: true, selector: "[brnTabsList]", host: { attributes: { "role": "tablist" }, properties: { "attr.aria-orientation": "_orientation()", "attr.data-orientation": "_orientation()" } }, queries: [{ propertyName: "triggers", predicate: BrnTabsTriggerDirective, descendants: true }], exportAs: ["brnTabsList"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsListDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnTabsList]',
                    standalone: true,
                    host: {
                        role: 'tablist',
                        '[attr.aria-orientation]': '_orientation()',
                        '[attr.data-orientation]': '_orientation()',
                    },
                    exportAs: 'brnTabsList',
                }]
        }], propDecorators: { triggers: [{
                type: ContentChildren,
                args: [BrnTabsTriggerDirective, { descendants: true }]
            }] } });

const BrnTabsImports = [
    BrnTabsDirective,
    BrnTabsListDirective,
    BrnTabsTriggerDirective,
    BrnTabsContentDirective,
];
class BrnTabsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsModule, imports: [BrnTabsDirective,
            BrnTabsListDirective,
            BrnTabsTriggerDirective,
            BrnTabsContentDirective], exports: [BrnTabsDirective,
            BrnTabsListDirective,
            BrnTabsTriggerDirective,
            BrnTabsContentDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTabsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnTabsImports],
                    exports: [...BrnTabsImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnTabsContentDirective, BrnTabsDirective, BrnTabsImports, BrnTabsListDirective, BrnTabsModule, BrnTabsTriggerDirective };
//# sourceMappingURL=spartan-ng-ui-tabs-brain.mjs.map
