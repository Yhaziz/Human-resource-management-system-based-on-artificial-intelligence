import * as i0 from '@angular/core';
import { InjectionToken, inject, ChangeDetectorRef, signal, computed, EventEmitter, booleanAttribute, Directive, Input, Output, forwardRef, DestroyRef, Component, ContentChildren, NgModule } from '@angular/core';
import { SelectionModel } from '@angular/cdk/collections';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { startWith, switchMap, of, merge, map } from 'rxjs';

const ToggleGroupCanBeNullableProvider = new InjectionToken('@spartan-ng/ui/brain toggle group can be nullable token');

let uniqueId = 0;
class BrnToggleDirective {
    constructor() {
        this._cdr = inject(ChangeDetectorRef);
        this._tgCanBeNullableProvider = inject(ToggleGroupCanBeNullableProvider, { optional: true });
        this._disabled = signal(undefined);
        this._state = signal('off', { equal: (a, b) => a === b });
        this.state = this._state.asReadonly();
        this.toggleDisabled = this._disabled.asReadonly();
        this.isOn = computed(() => this.state() === 'on');
        this.id = 'brn-toggle-' + uniqueId++;
        this._disableToggleClick = false;
        this.toggled = new EventEmitter();
    }
    set disabled(value) {
        this._disabled.set(value ? true : undefined);
    }
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set setState(value) {
        this._state.set(value);
    }
    set disableToggleClick(value) {
        this._disableToggleClick = value;
    }
    toggle() {
        if (this._disableToggleClick)
            return;
        if (this._state() === 'on') {
            this.toggleOff();
        }
        else {
            this.toggleOn();
        }
    }
    toggleOff() {
        if (this._tgCanBeNullableProvider && !this._tgCanBeNullableProvider._canBeNullable(this.value))
            return;
        this._state.set('off');
        this.toggled.emit('off');
    }
    toggleOn() {
        this._state.set('on');
        this.toggled.emit('on');
    }
    _markForCheck() {
        this._cdr.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.5", type: BrnToggleDirective, isStandalone: true, selector: "button[hlmToggle], button[brnToggle]", inputs: { id: "id", value: "value", disabled: ["disabled", "disabled", booleanAttribute], setState: ["state", "setState"], disableToggleClick: ["disableToggleClick", "disableToggleClick", booleanAttribute] }, outputs: { toggled: "toggled" }, host: { listeners: { "click": "toggle()" }, properties: { "attr.disabled": "toggleDisabled()", "attr.data-disabled": "toggleDisabled()", "attr.data-state": "state()", "attr.aria-pressed": "isOn()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'button[hlmToggle], button[brnToggle]',
                    standalone: true,
                    host: {
                        '[attr.disabled]': 'toggleDisabled()',
                        '[attr.data-disabled]': 'toggleDisabled()',
                        '[attr.data-state]': 'state()',
                        '[attr.aria-pressed]': 'isOn()',
                        '(click)': 'toggle()',
                    },
                }]
        }], propDecorators: { id: [{
                type: Input
            }], value: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], setState: [{
                type: Input,
                args: ['state']
            }], disableToggleClick: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], toggled: [{
                type: Output
            }] } });

const BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnToggleGroupComponent),
    multi: true,
};
let uniqueIdCounter = 0;
class BrnButtonToggleChange {
    constructor(source, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    value) {
        this.source = source;
        this.value = value;
    }
}
class BrnToggleGroupComponent {
    constructor() {
        this._cdr = inject(ChangeDetectorRef);
        this._destroyRef = inject(DestroyRef);
        this._vertical = false;
        this._multiple = false;
        this._nullable = false;
        this._skipNullableCheck = false;
        this._disabled = false;
        /**
         * The method to be called in order to update ngModel.
         */
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-explicit-any
        this._controlValueAccessorChangeFn = () => { };
        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
        // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-explicit-any
        this._onTouched = () => { };
        this._name = `brn-button-toggle-group-${uniqueIdCounter++}`;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.valueChange = new EventEmitter();
        this.change = new EventEmitter();
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        this._markTogglesForCheck();
    }
    get vertical() {
        return this._vertical;
    }
    set vertical(value) {
        this._vertical = value;
    }
    /** Value of the toggle group. */
    get value() {
        const selected = this._selectionModel ? this._selectionModel.selected : [];
        if (this.multiple) {
            return selected.map((toggle) => toggle.value);
        }
        return selected[0] ? selected[0].value : undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    set value(newValue) {
        if (this._disabled) {
            return;
        }
        this._setSelectionByValue(newValue);
        this.valueChange.emit(this.value);
    }
    /** Selected button toggles in the group. */
    get selected() {
        const selected = this._selectionModel ? this._selectionModel.selected : [];
        return this.multiple ? selected : selected[0] || null;
    }
    /** Whether no button toggles need to be selected. */
    get nullable() {
        return this._nullable;
    }
    set nullable(value) {
        this._nullable = value;
        this._markTogglesForCheck();
    }
    /** Whether multiple button toggles can be selected. */
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = value;
        this._markTogglesForCheck();
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
        this._buttonToggles?.forEach((toggle) => (toggle.disabled = this._disabled));
        this._markTogglesForCheck();
    }
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.multiple, undefined, false);
    }
    ngAfterContentInit() {
        if (!this._selectionModel || !this._buttonToggles)
            return;
        this._selectionModel.select(...this._buttonToggles.filter((toggle) => toggle.isOn()));
        this._buttonToggles.changes
            .pipe(startWith(this._buttonToggles), switchMap(() => {
            if (!this._buttonToggles)
                return of();
            return merge(...this._buttonToggles
                .toArray()
                .map((toggle) => toggle.toggled.asObservable().pipe(map((state) => ({ toggle: toggle, state })))));
        }), takeUntilDestroyed(this._destroyRef))
            .subscribe(({ state, toggle }) => {
            if (!this._selectionModel) {
                return;
            }
            this._onTouched();
            if (state === 'on') {
                if (!this.multiple) {
                    this._skipNullableCheck = true;
                    this._selectionModel.selected.forEach((s) => s.toggleOff());
                    this._skipNullableCheck = false;
                }
                this._selectionModel.select(toggle);
            }
            else {
                this._selectionModel.deselect(toggle);
            }
            this._updateModelValue(toggle);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    writeValue(value) {
        this.value = value;
        this._cdr.markForCheck();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnChange(fn) {
        this._controlValueAccessorChangeFn = fn;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _canBeNullable(value) {
        if (this._nullable || this._skipNullableCheck)
            return true;
        if (this._multiple) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return !(this.value.length === 1 && this.value[0] === value);
        }
        return this.value !== value;
    }
    /** Updates the selection state of the toggles in the group based on a value. */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setSelectionByValue(value) {
        if (!this._buttonToggles) {
            return;
        }
        if (this.multiple && value) {
            if (!Array.isArray(value)) {
                throw Error('Value must be an array in multiple-selection mode.');
            }
            this._clearSelection();
            value.forEach((currentValue) => this._selectValue(currentValue));
        }
        else {
            this._clearSelection();
            this._selectValue(value);
        }
    }
    /** Clears the selected toggles. */
    _clearSelection() {
        if (!this._selectionModel)
            return;
        this._selectionModel.clear();
        (this._buttonToggles ?? []).forEach((toggle) => toggle.toggleOff());
    }
    /** Selects a value if there's a toggle that corresponds to it. */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _selectValue(value) {
        if (!this._selectionModel)
            return;
        const correspondingOption = (this._buttonToggles ?? []).find((toggle) => {
            return toggle.value != null && toggle.value === value;
        });
        if (correspondingOption) {
            correspondingOption.toggleOn();
        }
    }
    _updateModelValue(toggle) {
        const value = this.value;
        const event = new BrnButtonToggleChange(toggle, value);
        this._controlValueAccessorChangeFn(value);
        this.change.emit(event);
        this.valueChange.emit(value);
    }
    /** Marks all the child button toggles to be checked. */
    _markTogglesForCheck() {
        this._buttonToggles?.forEach((toggle) => toggle._markForCheck());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.5", type: BrnToggleGroupComponent, isStandalone: true, selector: "brn-toggle-group", inputs: { name: "name", vertical: ["vertical", "vertical", booleanAttribute], value: "value", nullable: ["nullable", "nullable", booleanAttribute], multiple: ["multiple", "multiple", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute] }, outputs: { valueChange: "valueChange", change: "change" }, host: { attributes: { "role": "group" }, properties: { "attr.aria-disabled": "disabled", "attr.data-disabled": "disabled", "attr.data-vertical": "vertical" }, classAttribute: "brn-button-toggle-group" }, providers: [
            BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,
            {
                provide: ToggleGroupCanBeNullableProvider,
                useExisting: forwardRef(() => BrnToggleGroupComponent),
            },
        ], queries: [{ propertyName: "_buttonToggles", predicate: BrnToggleDirective, descendants: true }], exportAs: ["brnToggleGroup"], ngImport: i0, template: `
		<ng-content />
	`, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-toggle-group',
                    standalone: true,
                    providers: [
                        BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,
                        {
                            provide: ToggleGroupCanBeNullableProvider,
                            useExisting: forwardRef(() => BrnToggleGroupComponent),
                        },
                    ],
                    host: {
                        role: 'group',
                        class: 'brn-button-toggle-group',
                        '[attr.aria-disabled]': 'disabled',
                        '[attr.data-disabled]': 'disabled',
                        '[attr.data-vertical]': 'vertical',
                    },
                    exportAs: 'brnToggleGroup',
                    template: `
		<ng-content />
	`,
                }]
        }], propDecorators: { _buttonToggles: [{
                type: ContentChildren,
                args: [BrnToggleDirective, {
                        // Note that this would technically pick up toggles
                        // from nested groups, but that's not a case that we support.
                        descendants: true,
                    }]
            }], name: [{
                type: Input
            }], vertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], value: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], nullable: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], multiple: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], change: [{
                type: Output
            }] } });

class BrnToggleModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleModule, imports: [BrnToggleDirective], exports: [BrnToggleDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BrnToggleDirective],
                    exports: [BrnToggleDirective],
                }]
        }] });
class BrnToggleGroupModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleGroupModule, imports: [BrnToggleDirective, BrnToggleGroupComponent], exports: [BrnToggleDirective, BrnToggleGroupComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleGroupModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnToggleGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BrnToggleDirective, BrnToggleGroupComponent],
                    exports: [BrnToggleDirective, BrnToggleGroupComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, BrnButtonToggleChange, BrnToggleDirective, BrnToggleGroupComponent, BrnToggleGroupModule, BrnToggleModule };
//# sourceMappingURL=spartan-ng-ui-toggle-brain.mjs.map
