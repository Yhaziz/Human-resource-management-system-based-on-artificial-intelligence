/**
 * We are building on shoulders of giants here and adapt the implementation provided by the incredible Angular
 * team: https://github.com/angular/components/blob/main/src/material/tooltip/tooltip.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */
import { NgTemplateOutlet, isPlatformBrowser } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, PLATFORM_ID, Renderer2, ViewChild, ViewEncapsulation, inject, signal, } from '@angular/core';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * Internal component that wraps the tooltip's content.
 * @docs-private
 */
export class BrnTooltipContentComponent {
    constructor() {
        this._cdr = inject(ChangeDetectorRef);
        this._isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this._renderer2 = inject(Renderer2);
        this._contentHovered = signal(false);
        this._tooltipClasses = signal('');
        this.side = signal('above');
        /** Message to display in the tooltip */
        this.content = null;
        /** Amount of milliseconds to delay the closing sequence. */
        this._mouseLeaveHideDelay = 0;
        /** Amount of milliseconds of closing animation. */
        this._exitAnimationDuration = 0;
        /** Whether interactions on the page should close the tooltip */
        this._closeOnInteraction = false;
        /** Whether the tooltip is currently visible. */
        this._isVisible = false;
        /** Subject for notifying that the tooltip has been hidden from the view */
        this._onHide = new Subject();
        this.afterHidden = this._onHide.asObservable();
    }
    /**
     * Shows the tooltip with originating from the provided origin
     * @param delay Amount of milliseconds to the delay showing the tooltip.
     */
    show(delay) {
        // Cancel the delayed hide if it is scheduled
        if (this._hideTimeoutId != null) {
            clearTimeout(this._hideTimeoutId);
        }
        if (this._animateTimeoutId != null) {
            clearTimeout(this._animateTimeoutId);
        }
        this._showTimeoutId = setTimeout(() => {
            this._toggleDataAttributes(true, this.side());
            this._toggleVisibility(true);
            this._showTimeoutId = undefined;
        }, delay);
    }
    /**
     * Begins to hide the tooltip after the provided delay in ms.
     * @param delay Amount of milliseconds to delay hiding the tooltip.
     * @param exitAnimationDuration Time before hiding to finish animation
     * */
    hide(delay, exitAnimationDuration) {
        // Cancel the delayed show if it is scheduled
        if (this._showTimeoutId != null) {
            clearTimeout(this._showTimeoutId);
        }
        // start out animation at delay minus animation delay or immediately if possible
        this._animateTimeoutId = setTimeout(() => {
            this._animateTimeoutId = undefined;
            if (this._contentHovered())
                return;
            this._toggleDataAttributes(false, this.side());
        }, Math.max(delay, 0));
        this._hideTimeoutId = setTimeout(() => {
            this._hideTimeoutId = undefined;
            if (this._contentHovered())
                return;
            this._toggleVisibility(false);
        }, delay + exitAnimationDuration);
    }
    /** Whether the tooltip is being displayed. */
    isVisible() {
        return this._isVisible;
    }
    ngOnDestroy() {
        this._cancelPendingAnimations();
        this._onHide.complete();
        this._triggerElement = undefined;
    }
    _isTypeOfString(content) {
        return typeof content === 'string';
    }
    /**
     * Interactions on the HTML body should close the tooltip immediately as defined in the
     * material design spec.
     * https://material.io/design/components/tooltips.html#behavior
     */
    _handleBodyInteraction() {
        if (this._closeOnInteraction) {
            this.hide(0, 0);
        }
    }
    /**
     * Marks that the tooltip needs to be checked in the next change detection run.
     * Mainly used for rendering the initial text before positioning a tooltip, which
     * can be problematic in components with OnPush change detection.
     */
    _markForCheck() {
        this._cdr.markForCheck();
    }
    _handleMouseLeave({ relatedTarget }) {
        if (!relatedTarget || !this._triggerElement?.contains(relatedTarget)) {
            if (this.isVisible()) {
                this.hide(this._mouseLeaveHideDelay, this._exitAnimationDuration);
            }
            else {
                this._finalize(false);
            }
        }
        this._contentHovered.set(false);
    }
    /** Cancels any pending animation sequences. */
    _cancelPendingAnimations() {
        if (this._showTimeoutId != null) {
            clearTimeout(this._showTimeoutId);
        }
        if (this._hideTimeoutId != null) {
            clearTimeout(this._hideTimeoutId);
        }
        this._showTimeoutId = this._hideTimeoutId = undefined;
    }
    _finalize(toVisible) {
        if (toVisible) {
            this._closeOnInteraction = true;
        }
        else if (!this.isVisible()) {
            this._onHide.next();
        }
    }
    /** Toggles the visibility of the tooltip element. */
    _toggleVisibility(isVisible) {
        // We set the classes directly here ourselves so that toggling the tooltip state
        // isn't bound by change detection. This allows us to hide it even if the
        // view ref has been detached from the CD tree.
        const tooltip = this._tooltip?.nativeElement;
        if (!tooltip || !this._isBrowser)
            return;
        this._renderer2.setStyle(tooltip, 'visibility', isVisible ? 'visible' : 'hidden');
        this._isVisible = isVisible;
    }
    _toggleDataAttributes(isVisible, side) {
        // We set the classes directly here ourselves so that toggling the tooltip state
        // isn't bound by change detection. This allows us to hide it even if the
        // view ref has been detached from the CD tree.
        const tooltip = this._tooltip?.nativeElement;
        if (!tooltip || !this._isBrowser)
            return;
        this._renderer2.setAttribute(tooltip, 'data-side', side);
        this._renderer2.setAttribute(tooltip, 'data-state', isVisible ? 'open' : 'closed');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTooltipContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.5", type: BrnTooltipContentComponent, isStandalone: true, selector: "brn-tooltip-content", host: { attributes: { "aria-hidden": "true" }, listeners: { "mouseleave": "_handleMouseLeave($event)" }, properties: { "style.zoom": "isVisible() ? 1 : null" } }, viewQueries: [{ propertyName: "_tooltip", first: true, predicate: ["tooltip"], descendants: true, static: true }], ngImport: i0, template: `
		<div
			(mouseenter)="_contentHovered.set(true)"
			(mouseleave)="_contentHovered.set(false)"
			[class]="_tooltipClasses()"
			[style.visibility]="'hidden'"
			#tooltip
		>
			@if (_isTypeOfString(content)) {
				{{ content }}
			} @else {
				<ng-container [ngTemplateOutlet]="content" />
			}
		</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.5", ngImport: i0, type: BrnTooltipContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-tooltip-content',
                    standalone: true,
                    template: `
		<div
			(mouseenter)="_contentHovered.set(true)"
			(mouseleave)="_contentHovered.set(false)"
			[class]="_tooltipClasses()"
			[style.visibility]="'hidden'"
			#tooltip
		>
			@if (_isTypeOfString(content)) {
				{{ content }}
			} @else {
				<ng-container [ngTemplateOutlet]="content" />
			}
		</div>
	`,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        // Forces the element to have a layout in IE and Edge. This fixes issues where the element
                        // won't be rendered if the animations are disabled or there is no web animations polyfill.
                        '[style.zoom]': 'isVisible() ? 1 : null',
                        '(mouseleave)': '_handleMouseLeave($event)',
                        'aria-hidden': 'true',
                    },
                    imports: [NgTemplateOutlet],
                }]
        }], propDecorators: { _tooltip: [{
                type: ViewChild,
                args: ['tooltip', {
                        // Use a static query here since we interact directly with
                        // the DOM which can happen before `ngAfterViewInit`.
                        static: true,
                    }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJuLXRvb2x0aXAtY29udGVudC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL3VpL3Rvb2x0aXAvYnJhaW4vc3JjL2xpYi9icm4tdG9vbHRpcC1jb250ZW50LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdEUsT0FBTyxFQUNOLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFdBQVcsRUFDWCxTQUFTLEVBQ1QsU0FBUyxFQUNULGlCQUFpQixFQUNqQixNQUFNLEVBQ04sTUFBTSxHQUlOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBRS9COzs7R0FHRztBQThCSCxNQUFNLE9BQU8sMEJBQTBCO0lBN0J2QztRQThCa0IsU0FBSSxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ2pDLGVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUNwRCxlQUFVLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTdCLG9CQUFlLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRW5DLG9CQUFlLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzdCLFNBQUksR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkMsd0NBQXdDO1FBQ2pDLFlBQU8sR0FBeUMsSUFBSSxDQUFDO1FBWTVELDREQUE0RDtRQUNyRCx5QkFBb0IsR0FBRyxDQUFDLENBQUM7UUFDaEMsbURBQW1EO1FBQzVDLDJCQUFzQixHQUFHLENBQUMsQ0FBQztRQVVsQyxnRUFBZ0U7UUFDeEQsd0JBQW1CLEdBQUcsS0FB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LDBGQUEwRjt3QkFDMUYsMkZBQTJGO3dCQUMzRixjQUFjLEVBQUUsd0JBQXdCO3dCQUN4QyxjQUFjLEVBQUUsMkJBQTJCO3dCQUMzQyxhQUFhLEVBQUUsTUFBTTtxQkFDckI7b0JBQ0QsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLENBQUM7aUJBQzNCOzhCQWtDQSxRQUFRO3NCQUxQLFNBQVM7dUJBQUMsU0FBUyxFQUFFO3dCQUNyQiwwREFBMEQ7d0JBQzFELHFEQUFxRDt3QkFDckQsTUFBTSxFQUFFLElBQUk7cUJBQ1oiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdlIGFyZSBidWlsZGluZyBvbiBzaG91bGRlcnMgb2YgZ2lhbnRzIGhlcmUgYW5kIGFkYXB0IHRoZSBpbXBsZW1lbnRhdGlvbiBwcm92aWRlZCBieSB0aGUgaW5jcmVkaWJsZSBBbmd1bGFyXG4gKiB0ZWFtOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9jb21wb25lbnRzL2Jsb2IvbWFpbi9zcmMvbWF0ZXJpYWwvdG9vbHRpcC90b29sdGlwLnRzXG4gKiBDaGVjayB0aGVtIG91dCEgR2l2ZSB0aGVtIGEgdHJ5ISBMZWF2ZSBhIHN0YXIhIFRoZWlyIHdvcmsgaXMgaW5jcmVkaWJsZSFcbiAqL1xuXG5pbXBvcnQgeyBOZ1RlbXBsYXRlT3V0bGV0LCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuXHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcblx0Q2hhbmdlRGV0ZWN0b3JSZWYsXG5cdENvbXBvbmVudCxcblx0UExBVEZPUk1fSUQsXG5cdFJlbmRlcmVyMixcblx0Vmlld0NoaWxkLFxuXHRWaWV3RW5jYXBzdWxhdGlvbixcblx0aW5qZWN0LFxuXHRzaWduYWwsXG5cdHR5cGUgRWxlbWVudFJlZixcblx0dHlwZSBPbkRlc3Ryb3ksXG5cdHR5cGUgVGVtcGxhdGVSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHRoZSB0b29sdGlwJ3MgY29udGVudC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiAnYnJuLXRvb2x0aXAtY29udGVudCcsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PGRpdlxuXHRcdFx0KG1vdXNlZW50ZXIpPVwiX2NvbnRlbnRIb3ZlcmVkLnNldCh0cnVlKVwiXG5cdFx0XHQobW91c2VsZWF2ZSk9XCJfY29udGVudEhvdmVyZWQuc2V0KGZhbHNlKVwiXG5cdFx0XHRbY2xhc3NdPVwiX3Rvb2x0aXBDbGFzc2VzKClcIlxuXHRcdFx0W3N0eWxlLnZpc2liaWxpdHldPVwiJ2hpZGRlbidcIlxuXHRcdFx0I3Rvb2x0aXBcblx0XHQ+XG5cdFx0XHRAaWYgKF9pc1R5cGVPZlN0cmluZyhjb250ZW50KSkge1xuXHRcdFx0XHR7eyBjb250ZW50IH19XG5cdFx0XHR9IEBlbHNlIHtcblx0XHRcdFx0PG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50XCIgLz5cblx0XHRcdH1cblx0XHQ8L2Rpdj5cblx0YCxcblx0ZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG5cdGhvc3Q6IHtcblx0XHQvLyBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhIGxheW91dCBpbiBJRSBhbmQgRWRnZS4gVGhpcyBmaXhlcyBpc3N1ZXMgd2hlcmUgdGhlIGVsZW1lbnRcblx0XHQvLyB3b24ndCBiZSByZW5kZXJlZCBpZiB0aGUgYW5pbWF0aW9ucyBhcmUgZGlzYWJsZWQgb3IgdGhlcmUgaXMgbm8gd2ViIGFuaW1hdGlvbnMgcG9seWZpbGwuXG5cdFx0J1tzdHlsZS56b29tXSc6ICdpc1Zpc2libGUoKSA/IDEgOiBudWxsJyxcblx0XHQnKG1vdXNlbGVhdmUpJzogJ19oYW5kbGVNb3VzZUxlYXZlKCRldmVudCknLFxuXHRcdCdhcmlhLWhpZGRlbic6ICd0cnVlJyxcblx0fSxcblx0aW1wb3J0czogW05nVGVtcGxhdGVPdXRsZXRdLFxufSlcbmV4cG9ydCBjbGFzcyBCcm5Ub29sdGlwQ29udGVudENvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cdHByaXZhdGUgcmVhZG9ubHkgX2NkciA9IGluamVjdChDaGFuZ2VEZXRlY3RvclJlZik7XG5cdHByaXZhdGUgcmVhZG9ubHkgX2lzQnJvd3NlciA9IGlzUGxhdGZvcm1Ccm93c2VyKGluamVjdChQTEFURk9STV9JRCkpO1xuXHRwcml2YXRlIHJlYWRvbmx5IF9yZW5kZXJlcjIgPSBpbmplY3QoUmVuZGVyZXIyKTtcblxuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgX2NvbnRlbnRIb3ZlcmVkID0gc2lnbmFsKGZhbHNlKTtcblxuXHRwdWJsaWMgcmVhZG9ubHkgX3Rvb2x0aXBDbGFzc2VzID0gc2lnbmFsKCcnKTtcblx0cHVibGljIHJlYWRvbmx5IHNpZGUgPSBzaWduYWwoJ2Fib3ZlJyk7XG5cdC8qKiBNZXNzYWdlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgKi9cblx0cHVibGljIGNvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPHVua25vd24+IHwgbnVsbCA9IG51bGw7XG5cblx0LyoqIFRoZSB0aW1lb3V0IElEIG9mIGFueSBjdXJyZW50IHRpbWVyIHNldCB0byBzaG93IHRoZSB0b29sdGlwICovXG5cdHByaXZhdGUgX3Nob3dUaW1lb3V0SWQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuXHQvKiogVGhlIHRpbWVvdXQgSUQgb2YgYW55IGN1cnJlbnQgdGltZXIgc2V0IHRvIGhpZGUgdGhlIHRvb2x0aXAgKi9cblx0cHJpdmF0ZSBfaGlkZVRpbWVvdXRJZDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCB1bmRlZmluZWQ7XG5cdC8qKiBUaGUgdGltZW91dCBJRCBvZiBhbnkgY3VycmVudCB0aW1lciBzZXQgdG8gYW5pbWF0ZSB0aGUgdG9vbHRpcCAqL1xuXHRwcml2YXRlIF9hbmltYXRlVGltZW91dElkOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcblxuXHQvKiogRWxlbWVudCB0aGF0IGNhdXNlZCB0aGUgdG9vbHRpcCB0byBvcGVuLiAqL1xuXHRwdWJsaWMgX3RyaWdnZXJFbGVtZW50PzogSFRNTEVsZW1lbnQ7XG5cblx0LyoqIEFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIGNsb3Npbmcgc2VxdWVuY2UuICovXG5cdHB1YmxpYyBfbW91c2VMZWF2ZUhpZGVEZWxheSA9IDA7XG5cdC8qKiBBbW91bnQgb2YgbWlsbGlzZWNvbmRzIG9mIGNsb3NpbmcgYW5pbWF0aW9uLiAqL1xuXHRwdWJsaWMgX2V4aXRBbmltYXRpb25EdXJhdGlvbiA9IDA7XG5cblx0LyoqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgdG9vbHRpcCBlbGVtZW50LiAqL1xuXHRAVmlld0NoaWxkKCd0b29sdGlwJywge1xuXHRcdC8vIFVzZSBhIHN0YXRpYyBxdWVyeSBoZXJlIHNpbmNlIHdlIGludGVyYWN0IGRpcmVjdGx5IHdpdGhcblx0XHQvLyB0aGUgRE9NIHdoaWNoIGNhbiBoYXBwZW4gYmVmb3JlIGBuZ0FmdGVyVmlld0luaXRgLlxuXHRcdHN0YXRpYzogdHJ1ZSxcblx0fSlcblx0X3Rvb2x0aXA/OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuXHQvKiogV2hldGhlciBpbnRlcmFjdGlvbnMgb24gdGhlIHBhZ2Ugc2hvdWxkIGNsb3NlIHRoZSB0b29sdGlwICovXG5cdHByaXZhdGUgX2Nsb3NlT25JbnRlcmFjdGlvbiA9IGZhbHNlO1xuXG5cdC8qKiBXaGV0aGVyIHRoZSB0b29sdGlwIGlzIGN1cnJlbnRseSB2aXNpYmxlLiAqL1xuXHRwcml2YXRlIF9pc1Zpc2libGUgPSBmYWxzZTtcblxuXHQvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdGhlIHZpZXcgKi9cblx0cHJpdmF0ZSByZWFkb25seSBfb25IaWRlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcblx0cHVibGljIHJlYWRvbmx5IGFmdGVySGlkZGVuID0gdGhpcy5fb25IaWRlLmFzT2JzZXJ2YWJsZSgpO1xuXG5cdC8qKlxuXHQgKiBTaG93cyB0aGUgdG9vbHRpcCB3aXRoIG9yaWdpbmF0aW5nIGZyb20gdGhlIHByb3ZpZGVkIG9yaWdpblxuXHQgKiBAcGFyYW0gZGVsYXkgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZGVsYXkgc2hvd2luZyB0aGUgdG9vbHRpcC5cblx0ICovXG5cdHNob3coZGVsYXk6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIENhbmNlbCB0aGUgZGVsYXllZCBoaWRlIGlmIGl0IGlzIHNjaGVkdWxlZFxuXHRcdGlmICh0aGlzLl9oaWRlVGltZW91dElkICE9IG51bGwpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dElkKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVUaW1lb3V0SWQgIT0gbnVsbCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2FuaW1hdGVUaW1lb3V0SWQpO1xuXHRcdH1cblx0XHR0aGlzLl9zaG93VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHR0aGlzLl90b2dnbGVEYXRhQXR0cmlidXRlcyh0cnVlLCB0aGlzLnNpZGUoKSk7XG5cdFx0XHR0aGlzLl90b2dnbGVWaXNpYmlsaXR5KHRydWUpO1xuXHRcdFx0dGhpcy5fc2hvd1RpbWVvdXRJZCA9IHVuZGVmaW5lZDtcblx0XHR9LCBkZWxheSk7XG5cdH1cblxuXHQvKipcblx0ICogQmVnaW5zIHRvIGhpZGUgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIHByb3ZpZGVkIGRlbGF5IGluIG1zLlxuXHQgKiBAcGFyYW0gZGVsYXkgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBoaWRpbmcgdGhlIHRvb2x0aXAuXG5cdCAqIEBwYXJhbSBleGl0QW5pbWF0aW9uRHVyYXRpb24gVGltZSBiZWZvcmUgaGlkaW5nIHRvIGZpbmlzaCBhbmltYXRpb25cblx0ICogKi9cblx0aGlkZShkZWxheTogbnVtYmVyLCBleGl0QW5pbWF0aW9uRHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIENhbmNlbCB0aGUgZGVsYXllZCBzaG93IGlmIGl0IGlzIHNjaGVkdWxlZFxuXHRcdGlmICh0aGlzLl9zaG93VGltZW91dElkICE9IG51bGwpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZW91dElkKTtcblx0XHR9XG5cdFx0Ly8gc3RhcnQgb3V0IGFuaW1hdGlvbiBhdCBkZWxheSBtaW51cyBhbmltYXRpb24gZGVsYXkgb3IgaW1tZWRpYXRlbHkgaWYgcG9zc2libGVcblx0XHR0aGlzLl9hbmltYXRlVGltZW91dElkID0gc2V0VGltZW91dChcblx0XHRcdCgpID0+IHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZVRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKHRoaXMuX2NvbnRlbnRIb3ZlcmVkKCkpIHJldHVybjtcblx0XHRcdFx0dGhpcy5fdG9nZ2xlRGF0YUF0dHJpYnV0ZXMoZmFsc2UsIHRoaXMuc2lkZSgpKTtcblx0XHRcdH0sXG5cdFx0XHRNYXRoLm1heChkZWxheSwgMCksXG5cdFx0KTtcblx0XHR0aGlzLl9oaWRlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHR0aGlzLl9oaWRlVGltZW91dElkID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKHRoaXMuX2NvbnRlbnRIb3ZlcmVkKCkpIHJldHVybjtcblx0XHRcdHRoaXMuX3RvZ2dsZVZpc2liaWxpdHkoZmFsc2UpO1xuXHRcdH0sIGRlbGF5ICsgZXhpdEFuaW1hdGlvbkR1cmF0aW9uKTtcblx0fVxuXG5cdC8qKiBXaGV0aGVyIHRoZSB0b29sdGlwIGlzIGJlaW5nIGRpc3BsYXllZC4gKi9cblx0aXNWaXNpYmxlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pc1Zpc2libGU7XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpIHtcblx0XHR0aGlzLl9jYW5jZWxQZW5kaW5nQW5pbWF0aW9ucygpO1xuXHRcdHRoaXMuX29uSGlkZS5jb21wbGV0ZSgpO1xuXHRcdHRoaXMuX3RyaWdnZXJFbGVtZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0X2lzVHlwZU9mU3RyaW5nKGNvbnRlbnQ6IHVua25vd24pOiBjb250ZW50IGlzIHN0cmluZyB7XG5cdFx0cmV0dXJuIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcmFjdGlvbnMgb24gdGhlIEhUTUwgYm9keSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXAgaW1tZWRpYXRlbHkgYXMgZGVmaW5lZCBpbiB0aGVcblx0ICogbWF0ZXJpYWwgZGVzaWduIHNwZWMuXG5cdCAqIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2NvbXBvbmVudHMvdG9vbHRpcHMuaHRtbCNiZWhhdmlvclxuXHQgKi9cblx0X2hhbmRsZUJvZHlJbnRlcmFjdGlvbigpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5fY2xvc2VPbkludGVyYWN0aW9uKSB7XG5cdFx0XHR0aGlzLmhpZGUoMCwgMCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE1hcmtzIHRoYXQgdGhlIHRvb2x0aXAgbmVlZHMgdG8gYmUgY2hlY2tlZCBpbiB0aGUgbmV4dCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bi5cblx0ICogTWFpbmx5IHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgaW5pdGlhbCB0ZXh0IGJlZm9yZSBwb3NpdGlvbmluZyBhIHRvb2x0aXAsIHdoaWNoXG5cdCAqIGNhbiBiZSBwcm9ibGVtYXRpYyBpbiBjb21wb25lbnRzIHdpdGggT25QdXNoIGNoYW5nZSBkZXRlY3Rpb24uXG5cdCAqL1xuXHRfbWFya0ZvckNoZWNrKCk6IHZvaWQge1xuXHRcdHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcblx0fVxuXG5cdF9oYW5kbGVNb3VzZUxlYXZlKHsgcmVsYXRlZFRhcmdldCB9OiBNb3VzZUV2ZW50KSB7XG5cdFx0aWYgKCFyZWxhdGVkVGFyZ2V0IHx8ICF0aGlzLl90cmlnZ2VyRWxlbWVudD8uY29udGFpbnMocmVsYXRlZFRhcmdldCBhcyBOb2RlKSkge1xuXHRcdFx0aWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0dGhpcy5oaWRlKHRoaXMuX21vdXNlTGVhdmVIaWRlRGVsYXksIHRoaXMuX2V4aXRBbmltYXRpb25EdXJhdGlvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9maW5hbGl6ZShmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NvbnRlbnRIb3ZlcmVkLnNldChmYWxzZSk7XG5cdH1cblxuXHQvKiogQ2FuY2VscyBhbnkgcGVuZGluZyBhbmltYXRpb24gc2VxdWVuY2VzLiAqL1xuXHRfY2FuY2VsUGVuZGluZ0FuaW1hdGlvbnMoKSB7XG5cdFx0aWYgKHRoaXMuX3Nob3dUaW1lb3V0SWQgIT0gbnVsbCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0SWQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9oaWRlVGltZW91dElkICE9IG51bGwpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dElkKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zaG93VGltZW91dElkID0gdGhpcy5faGlkZVRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdHByaXZhdGUgX2ZpbmFsaXplKHRvVmlzaWJsZTogYm9vbGVhbikge1xuXHRcdGlmICh0b1Zpc2libGUpIHtcblx0XHRcdHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IHRydWU7XG5cdFx0fSBlbHNlIGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xuXHRcdFx0dGhpcy5fb25IaWRlLm5leHQoKTtcblx0XHR9XG5cdH1cblxuXHQvKiogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdG9vbHRpcCBlbGVtZW50LiAqL1xuXHRwcml2YXRlIF90b2dnbGVWaXNpYmlsaXR5KGlzVmlzaWJsZTogYm9vbGVhbikge1xuXHRcdC8vIFdlIHNldCB0aGUgY2xhc3NlcyBkaXJlY3RseSBoZXJlIG91cnNlbHZlcyBzbyB0aGF0IHRvZ2dsaW5nIHRoZSB0b29sdGlwIHN0YXRlXG5cdFx0Ly8gaXNuJ3QgYm91bmQgYnkgY2hhbmdlIGRldGVjdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG8gaGlkZSBpdCBldmVuIGlmIHRoZVxuXHRcdC8vIHZpZXcgcmVmIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gdGhlIENEIHRyZWUuXG5cdFx0Y29uc3QgdG9vbHRpcCA9IHRoaXMuX3Rvb2x0aXA/Lm5hdGl2ZUVsZW1lbnQ7XG5cdFx0aWYgKCF0b29sdGlwIHx8ICF0aGlzLl9pc0Jyb3dzZXIpIHJldHVybjtcblx0XHR0aGlzLl9yZW5kZXJlcjIuc2V0U3R5bGUodG9vbHRpcCwgJ3Zpc2liaWxpdHknLCBpc1Zpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJyk7XG5cdFx0dGhpcy5faXNWaXNpYmxlID0gaXNWaXNpYmxlO1xuXHR9XG5cblx0cHJpdmF0ZSBfdG9nZ2xlRGF0YUF0dHJpYnV0ZXMoaXNWaXNpYmxlOiBib29sZWFuLCBzaWRlOiBzdHJpbmcpIHtcblx0XHQvLyBXZSBzZXQgdGhlIGNsYXNzZXMgZGlyZWN0bHkgaGVyZSBvdXJzZWx2ZXMgc28gdGhhdCB0b2dnbGluZyB0aGUgdG9vbHRpcCBzdGF0ZVxuXHRcdC8vIGlzbid0IGJvdW5kIGJ5IGNoYW5nZSBkZXRlY3Rpb24uIFRoaXMgYWxsb3dzIHVzIHRvIGhpZGUgaXQgZXZlbiBpZiB0aGVcblx0XHQvLyB2aWV3IHJlZiBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIHRoZSBDRCB0cmVlLlxuXHRcdGNvbnN0IHRvb2x0aXAgPSB0aGlzLl90b29sdGlwPy5uYXRpdmVFbGVtZW50O1xuXHRcdGlmICghdG9vbHRpcCB8fCAhdGhpcy5faXNCcm93c2VyKSByZXR1cm47XG5cdFx0dGhpcy5fcmVuZGVyZXIyLnNldEF0dHJpYnV0ZSh0b29sdGlwLCAnZGF0YS1zaWRlJywgc2lkZSk7XG5cdFx0dGhpcy5fcmVuZGVyZXIyLnNldEF0dHJpYnV0ZSh0b29sdGlwLCAnZGF0YS1zdGF0ZScsIGlzVmlzaWJsZSA/ICdvcGVuJyA6ICdjbG9zZWQnKTtcblx0fVxufVxuIl19