import { Overlay, type ConnectedPosition, type OriginConnectionPosition, type OverlayConnectionPosition, type ScrollStrategy } from '@angular/cdk/overlay';
import { InjectionToken, type AfterViewInit, type OnDestroy, type TemplateRef } from '@angular/core';
import * as i0 from "@angular/core";
export type TooltipPosition = 'left' | 'right' | 'above' | 'below' | 'before' | 'after';
export type TooltipTouchGestures = 'auto' | 'on' | 'off';
/** Time in ms to throttle repositioning after scroll events. */
export declare const SCROLL_THROTTLE_MS = 20;
export declare function getBrnTooltipInvalidPositionError(position: string): Error;
/** Injection token that determines the scroll handling while a tooltip is visible. */
export declare const BRN_TOOLTIP_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;
export declare const BRN_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: (overlay: Overlay) => (() => ScrollStrategy);
};
export declare function BRN_TOOLTIP_DEFAULT_OPTIONS_FACTORY(): BrnTooltipOptions;
export declare const BRN_TOOLTIP_DEFAULT_OPTIONS: InjectionToken<BrnTooltipOptions>;
export interface BrnTooltipOptions {
    /** Default delay when the tooltip is shown. */
    showDelay: number;
    /** Default delay when the tooltip is hidden. */
    hideDelay: number;
    /** Default delay when hiding the tooltip on a touch device. */
    touchendHideDelay: number;
    /** Default touch gesture handling for tooltips. */
    touchGestures?: TooltipTouchGestures;
    /** Default position for tooltips. */
    position?: TooltipPosition;
    /**
     * Default value for whether tooltips should be positioned near the click or touch origin
     * instead of outside the element bounding box.
     */
    positionAtOrigin?: boolean;
    /** Disables the ability for the user to interact with the tooltip element. */
    disableTooltipInteractivity?: boolean;
}
export declare class BrnTooltipTriggerDirective implements OnDestroy, AfterViewInit {
    private readonly _tooltipDirective;
    private readonly _tooltipComponent;
    private readonly _cssClassPrefix;
    private readonly _destroyed;
    private readonly _passiveListeners;
    private readonly _defaultOptions;
    private readonly _overlay;
    private readonly _elementRef;
    private readonly _scrollDispatcher;
    private readonly _viewContainerRef;
    private readonly _ngZone;
    private readonly _platform;
    private readonly _ariaDescriber;
    private readonly _focusMonitor;
    private readonly _dir;
    private readonly _scrollStrategy;
    private readonly _document;
    private _portal?;
    private _viewInitialized;
    private _pointerExitEventsInitialized;
    private _viewportMargin;
    private _currentPosition?;
    private _touchstartTimeout?;
    private _overlayRef;
    private _tooltipInstance;
    /** Allows the user to define the position of the tooltip relative to the parent element */
    private readonly _position;
    get position(): TooltipPosition;
    set position(value: TooltipPosition);
    /**
     * Whether tooltip should be relative to the click or touch origin
     * instead of outside the element bounding box.
     */
    private readonly _positionAtOrigin;
    get positionAtOrigin(): boolean;
    set positionAtOrigin(value: boolean);
    /** Disables the display of the tooltip. */
    private readonly _disabled;
    get disabled(): boolean;
    set disabled(value: boolean);
    /** The default delay in ms before showing the tooltip after show is called */
    private readonly _showDelay;
    get showDelay(): number;
    set showDelay(value: number);
    /** The default delay in ms before hiding the tooltip after hide is called */
    private readonly _hideDelay;
    get hideDelay(): number;
    set hideDelay(value: number);
    /** The default duration in ms that exit animation takes before hiding */
    private readonly _exitAnimationDuration;
    get exitAnimationDuration(): number;
    set exitAnimationDuration(value: number);
    /** The default delay in ms before hiding the tooltip after hide is called */
    private readonly _tooltipContentClasses;
    get tooltipContentClasses(): string;
    set tooltipContentClasses(value: string | null | undefined);
    /**
     * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive
     * uses a long press gesture to show and hide, however it can conflict with the native browser
     * gestures. To work around the conflict, Angular Material disables native gestures on the
     * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable
     * elements). The different values for this option configure the touch event handling as follows:
     * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native
     *   browser gestures on particular elements. In particular, it allows text selection on inputs
     *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.
     * - `on` - Enables touch gestures for all elements and disables native
     *   browser gestures with no exceptions.
     * - `off` - Disables touch gestures. Note that this will prevent the tooltip from
     *   showing on touch devices.
     */
    private readonly _touchGestures;
    set touchGestures(value: TooltipTouchGestures);
    get touchGestures(): TooltipTouchGestures;
    /** The message to be used to describe the aria in the tooltip */
    private _ariaDescribedBy;
    get ariaDescribedBy(): string;
    set ariaDescribedBy(value: string);
    /** The content to be displayed in the tooltip */
    private _content;
    get content(): string | TemplateRef<unknown> | null;
    set content(value: string | TemplateRef<unknown> | null);
    constructor();
    ngAfterViewInit(): void;
    /**
     * Dispose the tooltip when destroyed.
     */
    ngOnDestroy(): void;
    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
    show(delay?: number, origin?: {
        x: number;
        y: number;
    }): void;
    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
    hide(delay?: number, exitAnimationDuration?: number): void;
    toggle(origin?: {
        x: number;
        y: number;
    }): void;
    _isTooltipVisible(): boolean;
    private _createOverlay;
    private _detach;
    private _updatePosition;
    /** Adds the configured offset to a position. Used as a hook for child classes. */
    protected _addOffset(position: ConnectedPosition): ConnectedPosition;
    /**
     * Returns the origin position and a fallback position based on the user's position preference.
     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
     */
    _getOrigin(): {
        main: OriginConnectionPosition;
        fallback: OriginConnectionPosition;
    };
    /** Returns the overlay position and a fallback position based on the user's preference */
    _getOverlayPosition(): {
        main: OverlayConnectionPosition;
        fallback: OverlayConnectionPosition;
    };
    /** Updates the tooltip message and repositions the overlay according to the new message length */
    private _updateTooltipContent;
    /** Inverts an overlay position. */
    private _invertPosition;
    /** Updates the class on the overlay panel based on the current position of the tooltip. */
    private _updateCurrentPositionClass;
    /** Binds the pointer events to the tooltip trigger. */
    private _setupPointerEnterEventsIfNeeded;
    private _setupPointerExitEventsIfNeeded;
    private _addListeners;
    private _platformSupportsMouseEvents;
    /** Listener for the `wheel` event on the element. */
    private _wheelListener;
    /** Disables the native browser gestures, based on how the tooltip has been configured. */
    private _disableNativeGesturesIfNecessary;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnTooltipTriggerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BrnTooltipTriggerDirective, "[brnTooltipTrigger]", ["brnTooltipTrigger"], { "position": { "alias": "position"; "required": false; }; "positionAtOrigin": { "alias": "positionAtOrigin"; "required": false; }; "disabled": { "alias": "brnTooltipDisabled"; "required": false; }; "showDelay": { "alias": "showDelay"; "required": false; }; "hideDelay": { "alias": "hideDelay"; "required": false; }; "exitAnimationDuration": { "alias": "exitAnimationDuration"; "required": false; }; "tooltipContentClasses": { "alias": "tooltipContentClasses"; "required": false; }; "touchGestures": { "alias": "touchGestures"; "required": false; }; "ariaDescribedBy": { "alias": "aria-describedby"; "required": false; }; "content": { "alias": "brnTooltipTrigger"; "required": false; }; }, {}, never, never, true, never>;
    static ngAcceptInputType_positionAtOrigin: unknown;
    static ngAcceptInputType_disabled: unknown;
    static ngAcceptInputType_showDelay: unknown;
    static ngAcceptInputType_hideDelay: unknown;
    static ngAcceptInputType_exitAnimationDuration: unknown;
}
