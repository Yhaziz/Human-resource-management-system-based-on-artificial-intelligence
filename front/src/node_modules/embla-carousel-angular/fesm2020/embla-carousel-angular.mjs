import * as i0 from '@angular/core';
import { InjectionToken, inject, NgZone, ElementRef, EventEmitter, Directive, Input, Output } from '@angular/core';
import EmblaCarousel from 'embla-carousel';
import { canUseDOM, areOptionsEqual, arePluginsEqual } from 'embla-carousel-reactive-utils';
import { Subject, throttleTime, takeUntil } from 'rxjs';

const EMBLA_OPTIONS_TOKEN = new InjectionToken('embla global options', {
    factory: () => undefined,
});
function provideEmblaGlobalOptions(options) {
    return [
        {
            provide: EMBLA_OPTIONS_TOKEN,
            useValue: options,
        },
    ];
}

class EmblaCarouselDirective {
    constructor() {
        this.globalOptions = inject(EMBLA_OPTIONS_TOKEN);
        this.ngZone = inject(NgZone);
        this._elementRef = inject(ElementRef);
        this.options = {};
        this.plugins = [];
        this.subscribeToEvents = [];
        this.eventsThrottleTime = 100;
        this.emblaChange = new EventEmitter();
        this.destroy$ = new Subject();
        this.storedOptions = this.options;
        this.storedPlugins = this.plugins;
        if (this.globalOptions) {
            EmblaCarousel.globalOptions = this.globalOptions;
        }
    }
    ngAfterViewInit() {
        if (!canUseDOM())
            return;
        this.ngZone.runOutsideAngular(() => {
            this.emblaApi = EmblaCarousel(this._elementRef.nativeElement, this.storedOptions, this.storedPlugins);
        });
        this.listenEvents();
    }
    ngOnChanges(changes) {
        const { plugins, options } = changes;
        if (options && !areOptionsEqual(this.storedOptions, options.currentValue)) {
            this.storedOptions = options.currentValue;
            this.reInit();
        }
        if (plugins && !arePluginsEqual(this.storedPlugins, plugins.currentValue)) {
            this.storedPlugins = plugins.currentValue;
            this.reInit();
        }
    }
    scrollTo(...args) {
        this.ngZone.runOutsideAngular(() => this.emblaApi?.scrollTo(...args));
    }
    scrollPrev(...args) {
        this.ngZone.runOutsideAngular(() => this.emblaApi?.scrollPrev(...args));
    }
    scrollNext(...args) {
        this.ngZone.runOutsideAngular(() => this.emblaApi?.scrollNext(...args));
    }
    reInit() {
        if (!this.emblaApi) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.emblaApi?.reInit(this.storedOptions, this.storedPlugins);
        });
    }
    /**
     * `eventsThrottler$` Subject was made just because `scroll` event fires too often.
     */
    listenEvents() {
        if (this.subscribeToEvents.length === 0) {
            return;
        }
        const eventsThrottler$ = new Subject();
        eventsThrottler$
            .pipe(throttleTime(this.eventsThrottleTime), takeUntil(this.destroy$))
            .subscribe(eventName => {
            this.ngZone.run(() => this.emblaChange.emit(eventName));
        });
        this.ngZone.runOutsideAngular(() => {
            this.subscribeToEvents.forEach(eventName => {
                this.emblaApi.on(eventName, () => eventsThrottler$.next(eventName));
            });
        });
    }
    ngOnDestroy() {
        this.emblaApi?.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
}
EmblaCarouselDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: EmblaCarouselDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
EmblaCarouselDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: EmblaCarouselDirective, isStandalone: true, selector: "[emblaCarousel]", inputs: { options: "options", plugins: "plugins", subscribeToEvents: "subscribeToEvents", eventsThrottleTime: "eventsThrottleTime" }, outputs: { emblaChange: "emblaChange" }, exportAs: ["emblaCarousel"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: EmblaCarouselDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[emblaCarousel]',
                    exportAs: 'emblaCarousel',
                    standalone: true,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { options: [{
                type: Input
            }], plugins: [{
                type: Input
            }], subscribeToEvents: [{
                type: Input
            }], eventsThrottleTime: [{
                type: Input
            }], emblaChange: [{
                type: Output
            }] } });

/*
 * Public API Surface of embla-carousel-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { EMBLA_OPTIONS_TOKEN, EmblaCarouselDirective, provideEmblaGlobalOptions };
//# sourceMappingURL=embla-carousel-angular.mjs.map
